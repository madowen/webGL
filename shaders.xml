<?xml version="1.0" encoding="UTF-8"?>
<shaders>
	<snippet id="test">
	<![CDATA[
		//THIS IS TEST!
	]]>		
	</snippet>

	<snippet id="spotFalloff">
		<![CDATA[
			float spotFalloff(vec3 spotDir,  vec3 lightDir, float angle_phi, float angle_theta)
			{
				float sqlen = dot(lightDir,lightDir);
				float atten = 1.0;

				vec4 spotParams = vec4( angle_phi, angle_theta, 1.0, 0.0 );
				spotParams.w = 1.0 / (spotParams.x-spotParams.y);

				vec3 dirUnit = lightDir * sqrt(sqlen); //we asume they are normalized
				float spotDot = dot(spotDir, -dirUnit);
				if (spotDot <= spotParams.y)// spotDot <= cos phi/2
					return 0.0;
				else if (spotDot > spotParams.x) // spotDot > cos theta/2
					return 1.0;

				// vertex lies somewhere beyond the two regions
				float ifallof = pow( (spotDot-spotParams.y)*spotParams.w,spotParams.z );
				return ifallof;
			}
		]]>
	</snippet>

	<snippet id="testShadow">
		<![CDATA[
			#ifndef SHADOWMAP_OFFSET 
				#define SHADOWMAP_OFFSET (1.0/1024.0)
			#endif 

			#ifdef USE_SHADOW_CUBEMAP
				uniform samplerCube shadowmap;
			#else
				uniform sampler2D shadowmap;
			#endif
			uniform vec4 u_shadow_params; // (1.0/(texture_size), bias, near, far)

			/*
			float UnpackDepth24(vec3 depth)
			{
				return dot(vec3(65536.0, 256.0, 1.0), depth) / 65025.0;
			}
			*/

			float UnpackDepth32(vec4 depth)
			{
				const vec4 bitShifts = vec4( 1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1);
				return dot(depth.xyzw , bitShifts);
			}

			float testShadow(vec2 offset)
			{
				float shadow = 0.0;
				float depth = 0.0;

				#ifdef USE_SHADOW_CUBEMAP
					
					vec3 l_vector = (v_pos - u_light_pos);
					float dist = length(l_vector);
					vec4 depth_color = textureCube(shadowmap, l_vector / dist + vec3(offset,0.0));
					//if ( abs(depth_color.x) + abs(depth_color.y) + abs(depth_color.z) + abs(depth_color.w) < 0.0001 ) return 0.0;
					float sampleDepth = UnpackDepth32( depth_color );
					depth = (sampleDepth == 1.0) ? 1.0e9 : sampleDepth; //on empty data send it to far away
					dist = (dist - u_shadow_params.z) / (u_shadow_params.w - u_shadow_params.z); //normalize
					float bias = u_shadow_params.y;
					return dist > depth * (1.0 + bias) ? 1.0 : 0.0;
				#else
					vec2 sample = (v_light_coord.xy / v_light_coord.w) * vec2(0.5) + vec2(0.5) + offset;
					//is inside light frustum
					if (clamp(sample, 0.0, 1.0) == sample) { 
						float sampleDepth = UnpackDepth32( texture2D(shadowmap, sample) );
						depth = (sampleDepth == 1.0) ? 1.0e9 : sampleDepth; //on empty data send it to far away
					}
					else 
						return 0.0; //outside of shadowmap, no shadow
				#endif

				if (depth > 0.0) {
					float bias = -1.0 * u_shadow_params.y;
					//multiply by 30 to get a little gradient
					//shadow = clamp(30.0 * (bias + v_light_coord.z / v_light_coord.w * 0.5 + 0.5 - depth), 0.0, 1.0);
					shadow = (bias + v_light_coord.z / v_light_coord.w * 0.5 + 0.5) > depth ? 1.0 : 0.0;
				}
				return shadow;
			}

		]]>
	</snippet>

	<snippet id="perturbNormal">
		<![CDATA[
			#extension GL_OES_standard_derivatives : enable 

			mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
			{
				// get edge vectors of the pixel triangle
				vec3 dp1 = dFdx( p );
				vec3 dp2 = dFdy( p );
				vec2 duv1 = dFdx( uv );
				vec2 duv2 = dFdy( uv );
			 
				// solve the linear system
				vec3 dp2perp = cross( dp2, N );
				vec3 dp1perp = cross( N, dp1 );
				vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
				vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
				//B *= -1.0; //reverse y, HACK, dont know why but works
			 
				// construct a scale-invariant frame 
				float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
				return mat3( T * invmax, B * invmax, N );
			}

			vec3 perturbNormal( vec3 N, vec3 V, vec2 texcoord, vec3 normal_pixel )
			{
				// assume N, the interpolated vertex normal and 
				// V, the view vector (vertex to eye)
				//vec3 normal_pixel = texture2D(normalmap, texcoord ).xyz;
				normal_pixel = normal_pixel * 255./127. - 128./127.;
				mat3 TBN = cotangent_frame(N, V, texcoord);
				return normalize(TBN * normal_pixel);
			}	
		]]>
	</snippet>

	<snippet id="bumpNormal">
		<![CDATA[
				#extension GL_OES_standard_derivatives : enable 

				// Calculate the surface normal using screen-space partial derivatives of the height field
				vec3 bumpNormal(vec3 position, vec3 normal, sampler2D texture, vec2 uvs, float factor)
				{
			        vec3 dpdx = dFdx(position);
			        vec3 dpdy = dFdy(position);
					vec3 r1 = cross(dpdy, normal);
					vec3 r2 = cross(normal, dpdx);
					vec2 dtdx = dFdx(uvs) * factor;
					vec2 dtdy = dFdy(uvs) * factor;

			        float h = texture2D( texture,  uvs ).r;
			        float hdx = texture2D( texture,  uvs + dtdx).r;
			        float hdy = texture2D( texture,  uvs + dtdy).r;					

					return normalize(normal - (r1 * (hdx - h) + r2 * (hdy - h)) / dot(dpdx, r1));						
				}
		]]>
	</snippet>

	<snippet id="skinning">
		<![CDATA[

				//I use three vector4 per bone instead of mat4 to save space
				#ifdef USE_SKINNING_TEXTURE
					uniform sampler2D u_bones;
				#else
					uniform vec4 u_bones[64*3];
				#endif
				attribute vec4 a_weights;
				attribute vec4 a_bone_indices;

				void getMat(int id, inout mat4 m) {

					#ifdef USE_SKINNING_TEXTURE
						m[0] = texture2D( u_bones, vec2( 0.0, (float(id*3)+0.5) / (64.0*3.0) ) ); 
						m[1] = texture2D( u_bones, vec2( 0.0, (float(id*3+1)+0.5) / (64.0*3.0) ) );
						m[2] = texture2D( u_bones, vec2( 0.0, (float(id*3+2)+0.5) / (64.0*3.0) ) );
					#else
						m[0] = u_bones[ id * 3];
						m[1] = u_bones[ id * 3 + 1];
						m[2] = u_bones[ id * 3 + 2];
					#endif
				}

				mat3 mat3_emu(mat4 m4) {
				  return mat3(
				      m4[0][0], m4[0][1], m4[0][2],
				      m4[1][0], m4[1][1], m4[1][2],
				      m4[2][0], m4[2][1], m4[2][2]);
				}	

				void applySkinning(inout vec4 position, inout vec3 normal)
				{
					/*
					vec3 pos = (position * u_bones[ int(a_bone_indices.x) ]).xyz * a_weights.x;
		        	pos += (position * u_bones[ int(a_bone_indices.y) ]).xyz * a_weights.y;
		        	pos += (position * u_bones[ int(a_bone_indices.z) ]).xyz * a_weights.z;
		        	pos += (position * u_bones[ int(a_bone_indices.w) ]).xyz * a_weights.w;
		        	position.xyz = pos;
		        	//*/

		        	//*
		        	//toji version seems faster
		        	mat4 bone_matrix = mat4(0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,1.0);

					getMat( int(a_bone_indices.x), bone_matrix );
		        	mat4 result = a_weights.x * bone_matrix;
		        	getMat( int(a_bone_indices.y), bone_matrix);
		        	result = result + a_weights.y * bone_matrix;
		        	getMat( int(a_bone_indices.z), bone_matrix);
		        	result = result + a_weights.z * bone_matrix;
		        	getMat( int(a_bone_indices.w), bone_matrix);
		        	result = result + a_weights.w * bone_matrix;

		        	position.xyz = (position * result).xyz;
		        	normal = normal * mat3_emu(result);
		        	//*/
		        	
				}
		]]>
	</snippet>

	<snippet id="surface_structs">
		<![CDATA[
				#extension GL_OES_standard_derivatives : enable 

				// Calculate the surface normal using screen-space partial derivatives of the height field
				vec3 bumpNormal(vec3 position, vec3 normal, sampler2D texture, vec2 uvs, float factor)
				{
			        vec3 dpdx = dFdx(position);
			        vec3 dpdy = dFdy(position);
					vec3 r1 = cross(dpdy, normal);
					vec3 r2 = cross(normal, dpdx);
					vec2 dtdx = dFdx(uvs) * factor;
					vec2 dtdy = dFdy(uvs) * factor;

			        float h = texture2D( texture,  uvs ).r;
			        float hdx = texture2D( texture,  uvs + dtdx).r;
			        float hdy = texture2D( texture,  uvs + dtdy).r;					

					return normalize(normal - (r1 * (hdx - h) + r2 * (hdy - h)) / dot(dpdx, r1));						
				}
		]]>
	</snippet>


	<shader id="surface" tags="instance" macros="NO_NORMALS,NO_COORDS,USE_COORDS1_STREAM,USE_COLOR_STREAM,USE_TANGENT_STREAM,USE_CLIPPING_PLANE,USE_ORTHOGRAPHIC_CAMERA,USE_VERTEX_SHADER_UNIFORMS,USE_VERTEX_SHADER_FUNCTIONS,USE_VERTEX_SHADER_CODE,USE_PIXEL_SHADER_UNIFORMS,USE_PIXEL_SHADER_FUNCTIONS,USE_PIXEL_SHADER_CODE,USE_SURFACE_SHADER,USE_SHADOW_MAP,SHADOWMAP_OFFSET,USE_SHADOW_CUBEMAP,USE_PROJECTIVE_LIGHT,USE_IGNORE_LIGHT,USE_LIGHT_OFFSET,USE_BACKLIGHT,FIRST_PASS,USE_AMBIENT_ONLY,USE_HARD_SHADOWS,USE_SPOT_CONE,USE_SPOT_LIGHT,USE_DIRECTIONAL_LIGHT,USE_DIFFUSE_LIGHT,USE_SPECULAR_LIGHT,USE_IRRADIANCE_CUBEMAP,USE_LINEAR_ATTENUATION,USE_RANGE_ATTENUATION,USE_ENVIRONMENT_TEXTURE,USE_ENVIRONMENT_CUBEMAP,USE_SPECULAR_ONTOP,USE_SKINNING,USE_SKINNING_TEXTURE" multipass="true" imports="true">
		<code type="vertex_shader">
		<![CDATA[
			precision mediump float;
			attribute vec3 a_vertex;

			#ifndef NO_NORMALS
				attribute vec3 a_normal;
			#endif

			#ifndef NO_COORDS
				attribute vec2 a_coord;
			#endif

			#ifdef USE_COORDS1_STREAM
				attribute vec2 a_coord1;
				varying vec2 v_uvs1;
			#endif

			#ifdef USE_COLOR_STREAM
				attribute vec4 a_color;
				varying vec4 v_color;
			#endif

			#ifdef USE_TANGENT_STREAM
				//attribute vec3 a_tangent;
			#endif

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			//uniform mat4 u_viewprojection;
			uniform mat4 u_normal_model;

			varying vec3 v_pos;
			varying vec3 v_local_pos;
			varying vec3 v_normal;
			varying vec3 v_local_normal;
			//varying vec3 v_tangent;
			varying vec2 v_uvs;

			uniform float u_time;			

			varying vec4 v_screenpos; //used for projective textures
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;

			#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
				uniform mat4 u_lightMatrix;
				varying vec4 v_light_coord;
			#endif			

			#ifdef USE_SKINNING
				#import "skinning"
			#endif

			#ifdef USE_VERTEX_SHADER_UNIFORMS
				USE_VERTEX_SHADER_UNIFORMS
			#endif

			#ifdef USE_VERTEX_SHADER_FUNCTIONS
				USE_VERTEX_SHADER_FUNCTIONS
			#endif

			void main() {

				vec3 vertex = a_vertex;

				#ifdef NO_NORMALS
					v_normal = vec3(0.,1.,0.);
				#else
					v_normal = a_normal;
				#endif

				#ifdef USE_COLOR_STREAM
					v_color = a_color;
				#endif

				v_uvs = a_coord;
				#ifdef NO_COORDS
					v_uvs = vec2(0.0);
				#endif

				#ifdef USE_COORDS1_STREAM
					v_uvs1 = a_coord1;
				#endif

				#ifdef USE_VERTEX_SHADER_CODE
					USE_VERTEX_SHADER_CODE
				#endif

				//position
				vec4 vertex4 = vec4(vertex,1.0);
				vec3 normal = v_normal;

				#ifdef USE_SKINNING
					applySkinning(vertex4, normal);
				#endif


				gl_Position =  u_mvp * vertex4;
				v_local_pos = vertex;
				v_pos = (u_model * vertex4).xyz;
				v_screenpos = gl_Position;

				//normal
				v_local_normal = normal;
				v_normal = (u_normal_model * vec4(normal,1.0)).xyz;

				#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
					v_light_coord = (u_lightMatrix) * vertex4;
				#endif				

				gl_PointSize = (u_pointSize / length(u_camera_eye - v_pos)) * u_camera_perspective.y; 
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision mediump float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			//varying vec3 v_tangent;
			varying vec4 v_screenpos; //used for projective textures
			varying vec3 v_local_pos;
			varying vec3 v_local_normal;

			#ifdef USE_COLOR_STREAM
				varying vec4 v_color;
			#endif

			#ifdef USE_COORDS1_STREAM
				varying vec2 v_uvs1;
			#endif
			
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_planes; //far near
			uniform vec2 u_camera_perspective;
			uniform vec4 u_clipping_plane;
			uniform float u_time;

			uniform vec4 u_material_color; //color and alpha

			struct Input {
				vec4 color;
				vec3 vertex;
				vec3 normal;
				vec2 uv;
				vec2 uv1;

				vec3 camPos;
				vec3 viewDir;
				vec3 worldPos;
				vec3 worldNormal;
				vec4 screenPos;
			};

			struct SurfaceOutput {
				vec3 Albedo;
				vec3 Normal;
				vec3 Emission;
				float Specular;
				float Gloss;
				float Alpha;
				float Reflectivity;
			};

			uniform vec3 u_ambient_light;
			uniform vec3 u_background_color;
			uniform vec3 u_light_pos;
			uniform vec3 u_light_front;
			uniform vec3 u_light_color;
			uniform vec4 u_light_angle; //cone start,end,phi,theta
			uniform vec2 u_light_att; //start,end

			#ifdef USE_LIGHT_OFFSET
				uniform float u_light_offset;
			#endif			

			#ifdef USE_PROJECTIVE_LIGHT
				uniform sampler2D light_texture;
			#endif

			#ifdef USE_ENVIRONMENT_TEXTURE
				uniform sampler2D environment_texture;
			#endif			

			#ifdef USE_ENVIRONMENT_CUBEMAP
				uniform samplerCube environment_cubemap;
			#endif			

			#ifdef USE_IRRADIANCE_CUBEMAP
				uniform samplerCube irradiance_cubemap;
			#endif			

			#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
				varying vec4 v_light_coord;
			#endif

			#ifdef USE_SPOT_LIGHT
				#import "spotFalloff"
			#endif

			#ifdef USE_SHADOW_MAP
				#import "testShadow"
			#endif

			//***** Global input and output variables
			Input IN;
			SurfaceOutput o;

			//***** Useful functions
			vec2 polarToCartesian(in vec3 V)
			{
				return vec2( 0.5 - (atan(V.z, V.x) / -6.28318531), asin(V.y) / 1.57079633 * 0.5 + 0.5);
			}					
			
			//***** compute Light
			vec3 computeLight(in SurfaceOutput IN)
			{
				vec3 final_color = vec3(0.0);
				vec3 N = IN.Normal;
				float spec_light = 0.0;

				//lighting calculation
				float shadow = 1.0;
				#if defined(USE_SHADOW_MAP) && !defined(USE_AMBIENT_ONLY)
					#ifdef USE_HARD_SHADOWS
						shadow = 1.0 - testShadow(vec2(0.,0.));
					#else
						if (v_light_coord.w > 0.0) //inside the light frustrum
						{
							shadow = 2.0 * testShadow(vec2(0.0,0.0));
							shadow += testShadow(vec2(0.0,u_shadow_params.x));
							shadow += testShadow(vec2(0.0,-u_shadow_params.x));
							shadow += testShadow(vec2(-u_shadow_params.x,0.0));
							shadow += testShadow(vec2(u_shadow_params.x,0.0));
							shadow += testShadow(vec2(-u_shadow_params.x,-u_shadow_params.x));
							shadow += testShadow(vec2(u_shadow_params.x,-u_shadow_params.x));
							shadow += testShadow(vec2(-u_shadow_params.x,u_shadow_params.x));
							shadow += testShadow(vec2(u_shadow_params.x,u_shadow_params.x));
							shadow = 1.0 - shadow * 0.1;
						}
					#endif	
				#endif

				vec3 E = (u_camera_eye - v_pos);
				float cam_dist = length(E);

				#ifdef USE_ORTHOGRAPHIC_CAMERA
					E = normalize(u_camera_eye); //wrong, should be center - eye
				#else
					E /= cam_dist;
				#endif

				vec3 L = (u_light_pos - v_pos);
				float light_dist = length(L);
				L /= light_dist;

				#if defined(USE_SPOT_LIGHT) || defined(USE_DIRECTIONAL_LIGHT)
					L = -u_light_front;
				#endif

				vec3 R = reflect(E,N);

				float NdotL = 1.0;
				#ifdef USE_DIFFUSE_LIGHT
					NdotL = dot(N,L);
				#endif
				float EdotN = dot(E,N); //clamp(dot(E,N),0.0,1.0);
				spec_light = IN.Specular * pow( clamp(dot(R,-L),0.001,1.0), IN.Gloss);

				vec3 light = vec3(0.0);

				//ambient light
				vec3 ambient = vec3(0.0);
				#ifdef FIRST_PASS
					ambient = u_ambient_light;
					#ifdef USE_IRRADIANCE_CUBEMAP
						ambient *= textureCube( irradiance_cubemap, N).xyz;
					#else
					/*
						#ifdef USE_IRRADIANCE_TEXTURE
							ambient *= texture2D(irradiance_texture, uvs_polar_reflected ).xyz;
						#endif
					*/
					#endif
				#endif
				light += ambient;

				float att = 1.0;
				#ifdef USE_LINEAR_ATTENUATION
					att = 100.0 / light_dist;
				#endif

				#ifdef USE_RANGE_ATTENUATION
					if(light_dist >= u_light_att.y)
						att = 0.0;
					else if(light_dist >= u_light_att.x)
						att *= 1.0 - (light_dist - u_light_att.x) / (u_light_att.y - u_light_att.x);
				#endif

				vec3 light_color = u_light_color;

				#ifdef USE_PROJECTIVE_LIGHT
					vec2 light_sample = (v_light_coord.xy / v_light_coord.w) * vec2(0.5) + vec2(0.5);
					light_color *= texture2D(light_texture,light_sample).xyz;

					#ifndef USE_SPOT_CONE
						if (light_sample.x < 0.001 || light_sample.y < 0.001 || light_sample.x > 0.999 || light_sample.y > 0.999)
							att = 0.0;
					#endif
				#endif

				#ifdef USE_SPOT_LIGHT
					#ifdef USE_SPOT_CONE
						att *= spotFalloff(u_light_front, -normalize(u_light_pos - v_pos), u_light_angle.z, u_light_angle.w);
					#endif
				#endif

				#ifndef USE_AMBIENT_ONLY
					#ifdef USE_LIGHT_OFFSET
						NdotL += u_light_offset;
					#endif

					#ifdef USE_BACKLIGHT
						//if(NdotL > 0.0 != gl_FrontFacing)	NdotL *= u_backlight_factor;
						if(NdotL < 0.0 && gl_FrontFacing)	NdotL *= u_backlight_factor;
					#else
						//if(NdotL > 0.0 != gl_FrontFacing) NdotL = 0.0;
						NdotL = max(0.0, NdotL * (gl_FrontFacing ? 1.0 : 0.0 ));
					#endif

					NdotL = abs(NdotL);
					light += light_color * (att * ( NdotL + spec_light ) * shadow); 
				#endif

				//emissive
				light += IN.Emission;

				#ifdef USE_IGNORE_LIGHT
					light = vec3(1.0);
				#endif

				//FINAL COLOR ************************* 
				final_color = IN.Albedo * light;

				final_color = max(final_color, vec3(0.0)); //(clamped from 0)


				//REFLECTION
				vec3 reflection_color = u_background_color;

				#ifdef FIRST_PASS
				if(IN.Reflectivity > 0.0)
				{
					//compute reflection color from environment
					#if defined(USE_ENVIRONMENT_TEXTURE) || defined(USE_ENVIRONMENT_CUBEMAP)

						#ifdef USE_ENVIRONMENT_CUBEMAP
							reflection_color = textureCube(environment_cubemap, -R, 0.0).xyz;
						#else //USE_ENVIRONMENT_TEXTURE
							vec2 uvs_polar_reflected = polarToCartesian(-R);
							reflection_color = texture2D(environment_texture, uvs_polar_reflected ).xyz;
						#endif

					#endif //environment

					//apply reflection
					final_color = final_color * max(0.0, 1.0 - IN.Reflectivity) + reflection_color * IN.Reflectivity;
				}
				#endif //firstpass

				return final_color;
			}

			//to use normalmaps
			#import "perturbNormal"

			#ifdef USE_PIXEL_SHADER_UNIFORMS
				USE_PIXEL_SHADER_UNIFORMS
			#endif

			#ifdef USE_PIXEL_SHADER_FUNCTIONS
				USE_PIXEL_SHADER_FUNCTIONS
			#endif

			#ifdef USE_SURFACE_SHADER
				USE_SURFACE_SHADER
			#else
				void surf(in Input IN, inout SurfaceOutput o)
				{
				}
			#endif

			void main() {

				#ifdef USE_CLIPPING_PLANE
					if( dot(v_pos, u_clipping_plane.xyz) < u_clipping_plane.w)
						discard;
				#endif
				
				IN.vertex = v_local_pos;
				IN.normal = v_local_normal;
				IN.color = u_material_color;
				#ifdef USE_COLOR_STREAM
					IN.color = v_color;
				#endif
				IN.uv = v_uvs;

				#ifdef USE_COORD1_STREAM
					IN.uv1 = v_uvs1;
				#endif

				IN.camPos = u_camera_eye;
				IN.viewDir = normalize(u_camera_eye - v_pos);
				IN.worldPos = v_pos;
				IN.worldNormal = normalize(v_normal);
				IN.screenPos = v_screenpos;  //(v_screenpos.xy / v_screenpos.w) * 0.5 + 0.5;

				o.Albedo = IN.color.xyz;
				o.Normal = IN.worldNormal;
				o.Emission = vec3(0.0);
				o.Specular = 0.0;
				o.Gloss = 0.0;
				o.Alpha = IN.color.a;
				o.Reflectivity = 0.0;

				//* INCLUDED CODE ***************************
				#ifdef USE_PIXEL_SHADER_CODE
					USE_PIXEL_SHADER_CODE
				#endif				
				//********************************************

				surf(IN,o);

				#ifdef USE_ALPHA_TEST
					if(o.Alpha < USE_ALPHA_TEST)
						discard;
				#endif

				//generate lighting
				gl_FragColor = vec4( computeLight(o), o.Alpha );
			}
		]]>
		</code>
	</shader>	

	<shader id="base" tags="instance" macros="NO_NORMALS,NO_COORDS,USE_COLOR_STREAM,USE_TANGENT_STREAM,USE_COLOR_TEXTURE,USE_COLOR_CUBEMAP,USE_CLIPPING_PLANE,USE_ORTHOGRAPHIC_CAMERA,USE_VERTEX_SHADER_UNIFORMS,USE_VERTEX_SHADER_FUNCTIONS,USE_VERTEX_SHADER_CODE,USE_PIXEL_SHADER_UNIFORMS,USE_PIXEL_SHADER_FUNCTIONS,USE_PIXEL_SHADER_CODE" multipass="false">
		<code type="vertex_shader">
		<![CDATA[
			precision mediump float;
			attribute vec3 a_vertex;

			#ifndef NO_NORMALS
				attribute vec3 a_normal;
			#endif

			#ifndef NO_COORDS
				attribute vec2 a_coord;
			#endif

			#ifdef USE_COLOR_STREAM
				attribute vec4 a_color;
				varying vec4 v_color;
			#endif

			#ifdef USE_TANGENT_STREAM
				//attribute vec3 a_tangent;
			#endif

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			//uniform mat4 u_viewprojection;
			uniform mat4 u_normal_model;

			uniform mat3 u_texture_matrix; //matrix to modify uvs
			varying vec2 v_uvs_transformed;

			varying vec3 v_pos;
			varying vec3 v_local_pos;
			varying vec3 v_normal;
			//varying vec3 v_tangent;
			varying vec2 v_uvs;

			varying vec4 v_screenpos; //used for projective textures
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;

			#ifdef USE_VERTEX_SHADER_UNIFORMS
				USE_VERTEX_SHADER_UNIFORMS
			#endif

			#ifdef USE_VERTEX_SHADER_FUNCTIONS
				USE_VERTEX_SHADER_FUNCTIONS
			#endif

			void main() {

				vec3 vertex = a_vertex;

				#ifdef NO_NORMALS
					v_normal = vec3(0.,1.,0.);
				#else
					v_normal = a_normal;
				#endif

				/*
				#ifndef USE_TANGENT_STREAM
					v_tangent = vec3(1.,0.,0.);
				#else
					v_tangent = (u_normal_model * vec4(a_tangent,1.0)).xyz;
				#endif
				*/

				#ifdef USE_COLOR_STREAM
					v_color = a_color;
				#endif

				#ifdef NO_COORDS
					v_uvs = vec2(0.5);
				#else
					v_uvs = a_coord;
				#endif

				#ifdef USE_VERTEX_SHADER_CODE
					USE_VERTEX_SHADER_CODE
				#endif

				//position
				gl_Position =  u_mvp * vec4(vertex,1.0);
				v_local_pos = vertex;
				v_pos = (u_model * vec4(vertex,1.0)).xyz;
				v_screenpos = gl_Position;

				//normal
				v_normal = (u_normal_model * vec4(v_normal,1.0)).xyz;

				gl_PointSize = (u_pointSize / length(u_camera_eye - v_pos)) * u_camera_perspective.y; 
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision mediump float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			//varying vec3 v_tangent;
			varying vec4 v_screenpos; //used for projective textures
			varying vec3 v_local_pos;

			varying vec2 v_uvs_transformed;

			#ifdef USE_COLOR_STREAM
				varying vec4 v_color;
			#endif
			
			#ifdef USE_COLOR_TEXTURE
				uniform sampler2D color_texture;
			#endif

			#ifdef USE_COLOR_CUBEMAP
				uniform samplerCube color_cubemap;
			#endif

			uniform vec4 u_material_color;
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_planes; //far near

			uniform vec4 u_clipping_plane;
			uniform float u_time;

			#ifdef USE_PIXEL_SHADER_UNIFORMS
				USE_PIXEL_SHADER_UNIFORMS
			#endif

			#ifdef USE_PIXEL_SHADER_FUNCTIONS
				USE_PIXEL_SHADER_FUNCTIONS
			#endif

			vec2 polarToCartesian(in vec3 V)
			{
				return vec2( 0.5 - (atan(V.z, V.x) / -6.28318531), asin(V.y) / 1.57079633 * 0.5 + 0.5);
			}				
			
			void main() {
				float temp = 0.0;
				vec2 temp_v2 = vec2(0.0);
				vec3 temp_v3 = vec3(0.0);

				#ifdef USE_CLIPPING_PLANE
					if( dot(v_pos, u_clipping_plane.xyz) < u_clipping_plane.w)
						discard;
				#endif
				
				//surface color
				vec3 final_color = vec3(0.0);
				vec3 color = u_material_color.xyz;
				float alpha = u_material_color.a;
				#ifdef USE_COLOR_STREAM
					color *= v_color.xyz;
					alpha *= v_color.w;
				#endif

				vec3 N = normalize(v_normal);
				vec3 localPosN = normalize(v_local_pos);

				//* COMPUTE TEXTURE COORDINATES ***************************
				vec2 uvs_0 = v_uvs;
				vec2 uvs_1 = uvs_0;
				vec2 uvs_transformed = v_uvs_transformed;
				vec2 uvs_worldxy = v_pos.xy * 0.1;
				vec2 uvs_worldxz = v_pos.xz * 0.1;
				vec2 uvs_worldyz = v_pos.yz * 0.1;
				vec2 uvs_screen = (v_screenpos.xy / v_screenpos.w) * 0.5 + 0.5;
				vec2 uvs_flipped_screen = vec2(1.0 - uvs_screen.x, uvs_screen.y);

				vec2 uvs_polar = polarToCartesian(N);
				vec2 uvs_polar_reflected = uvs_polar; //computed later when we know the Reflected vector
				vec2 uvs_polar_vertex = polarToCartesian(localPosN);


				#ifdef USE_ALPHA_TEST
					if(alpha < USE_ALPHA_TEST)
						discard;
				#endif
				
				vec3 E = (u_camera_eye - v_pos);
				float cam_dist = length(E);

				#ifdef USE_ORTHOGRAPHIC_CAMERA
					E = normalize(u_camera_eye); //wrong, should be center - eye
				#else
					E /= cam_dist;
				#endif

				vec3 R = reflect(E,N);
				uvs_polar_reflected = polarToCartesian(-R);

				//* INCLUDED CODE ***************************
				#ifdef USE_PIXEL_SHADER_CODE
					USE_PIXEL_SHADER_CODE
				#endif				
				//********************************************

				//FINAL COLOR ************************* (clamped from 0)
				final_color = max(color, vec3(0.0));

				gl_FragColor = vec4(final_color, alpha); //regular color
			}
		]]>
		</code>
	</shader>


	<shader id="global" tags="instance" multipass="true" imports="true">
		<macros>
			NO_NORMALS, NO_COORDS, USE_COORDS1_STREAM, USE_COLOR_STREAM, USE_TANGENT_STREAM,
			USE_ALPHA_TEST, USE_POINTS,USE_CLIPPING_PLANE,USE_BRIGHTNESS_FACTOR,USE_COLORCLIP_FACTOR,USE_TEXTURE_MATRIX,
			USE_COLOR_TEXTURE, USE_COLOR_CUBEMAP, USE_OPACITY_TEXTURE, USE_SPECULAR_TEXTURE, USE_AMBIENT_TEXTURE,
			USE_EMISSIVE_TEXTURE, USE_EMISSIVE_MATERIAL, USE_SHADOW_MAP, USE_SHADOW_CUBEMAP, SHADOWMAP_OFFSET,
			USE_VELVET, USE_VELVET_ALPHA, USE_DETAIL_TEXTURE, USE_NORMAL_TEXTURE,
			USE_NORMALMAP_FACTOR, USE_TANGENT_NORMALMAP,
			USE_BUMP_TEXTURE, USE_BUMP_FACTOR, USE_DISPLACEMENT_TEXTURE, USE_DISPLACEMENTMAP_FACTOR,
			USE_REFLECTION, USE_REFLECTIVITY_TEXTURE, USE_ENVIRONMENT_TEXTURE, USE_ENVIRONMENT_CUBEMAP, USE_IRRADIANCE_TEXTURE,USE_IRRADIANCE_CUBEMAP,
			USE_DIRECTIONAL_LIGHT, USE_SPOT_LIGHT, USE_LINEAR_ATTENUATION, USE_RANGE_ATTENUATION, USE_DIFFUSE_LIGHT,USE_SPECULAR_LIGHT,USE_AMBIENT_ONLY,USE_IGNORE_LIGHT,USE_HARD_SHADOWS,
			USE_SPECULAR_ONTOP, USE_SPECULAR_ON_ALPHA, USE_SPECULAR_IN_REFLECTION, USE_BACKLIGHT, USE_LIGHT_OFFSET, USE_SPOT_CONE,
			USE_PROJECTIVE_LIGHT, USE_PROJECTIVE_LIGHT_CUBEMAP, USE_TEXTURE_AVERAGE_LIGHT,
			USE_FOG, USE_FOG_EXP, USE_FOG_EXP2,
			USE_ORTHOGRAPHIC_CAMERA, USE_SOFT_PARTICLES, FIRST_PASS, USE_VERTEX_SHADER_UNIFORMS, USE_VERTEX_SHADER_FUNCTIONS,USE_VERTEX_SHADER_CODE,USE_SKINNING,USE_SKINNING_TEXTURE
		</macros>
		<code type="vertex_shader">
		<![CDATA[
			precision mediump float;
			attribute vec3 a_vertex;

			#ifndef NO_NORMALS
				attribute vec3 a_normal;
			#endif

			#ifndef NO_COORDS
				attribute vec2 a_coord;
			#endif

			#ifdef USE_COORDS1_STREAM
				attribute vec2 a_coord1;
				varying vec2 v_uvs1;
			#endif			

			#ifdef USE_COLOR_STREAM
				attribute vec4 a_color;
				varying vec4 v_color;
			#endif

			#ifdef USE_TANGENT_STREAM
				//attribute vec3 a_tangent;
			#endif

			#ifdef USE_DISPLACEMENT_TEXTURE
				uniform sampler2D displacement_texture;
			#endif

			#ifdef USE_DISPLACEMENTMAP_FACTOR
				uniform float u_displacementmap_factor;
			#endif

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			//uniform mat4 u_viewprojection;
			uniform mat4 u_normal_model;

			uniform mat3 u_texture_matrix; //matrix to modify uvs
			varying vec2 v_uvs_transformed;

			varying vec3 v_pos;
			varying vec3 v_local_pos;
			varying vec3 v_normal;
			//varying vec3 v_tangent;
			varying vec2 v_uvs;

			varying vec4 v_screenpos; //used for projective textures
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;

			#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
				uniform mat4 u_lightMatrix;
				varying vec4 v_light_coord;
			#endif

			#ifdef USE_SKINNING
				#import "skinning"
			#endif			

			#ifdef USE_VERTEX_SHADER_UNIFORMS
				USE_VERTEX_SHADER_UNIFORMS
			#endif

			#ifdef USE_VERTEX_SHADER_FUNCTIONS
				USE_VERTEX_SHADER_FUNCTIONS
			#endif

			void main() {

				vec4 vertex4 = vec4(a_vertex,1.0);

				#ifdef NO_NORMALS
					v_normal = vec3(0.,1.,0.);
				#else
					v_normal = a_normal;
				#endif

				/*
				#ifndef USE_TANGENT_STREAM
					v_tangent = vec3(1.,0.,0.);
				#else
					v_tangent = (u_normal_model * vec4(a_tangent,1.0)).xyz;
				#endif
				*/

				#ifdef USE_COLOR_STREAM
					v_color = a_color;
				#endif

				#ifdef NO_COORDS
					v_uvs = vec2(0.5);
				#else
					v_uvs = a_coord;
				#endif

				#ifdef USE_COORDS1_STREAM
					v_uvs1 = a_coord1;
				#endif				

				v_uvs_transformed = (u_texture_matrix * vec3(v_uvs,1.0)).xy;

				#ifdef USE_SKINNING
					applySkinning(vertex4, v_normal);
				#endif				

				#ifdef USE_VERTEX_SHADER_CODE
					USE_VERTEX_SHADER_CODE
				#endif


				#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
					v_light_coord = (u_lightMatrix) * vertex4;
				#endif

				#ifdef USE_DISPLACEMENT_TEXTURE
					vec2 uvs_0 = v_uvs;
					vec2 uvs_1 = uvs_0;
					vec2 uvs_transformed = v_uvs_transformed;

					float height = texture2D( displacement_texture, USE_DISPLACEMENT_TEXTURE ).x;
					#ifdef USE_DISPLACEMENTMAP_FACTOR
						height *= u_displacementmap_factor;
					#endif
					vertex4.xyz += v_normal * height;
				#endif


				//position
				gl_Position =  u_mvp * vertex4;
				//gl_Position.xy = (v_uvs * 2.0 - 1.0) * gl_Position.w ; // lightmapping
				v_local_pos = vertex4.xyz;
				v_pos = (u_model * vertex4).xyz;
				v_screenpos = gl_Position;

				//normal
				v_normal = (u_normal_model * vec4(v_normal,1.0)).xyz;

				gl_PointSize = (u_pointSize / length(u_camera_eye - v_pos)) * u_camera_perspective.y; 
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision mediump float;

			varying vec3 v_pos; //position in wold space
			varying vec3 v_normal; //normal in world space
			varying vec2 v_uvs;
			varying vec2 v_uvs_transformed;
			//varying vec3 v_tangent;
			varying vec4 v_screenpos; //used for projective textures
			varying vec3 v_local_pos; //position in local space

			#ifdef USE_COLOR_STREAM
				varying vec4 v_color;
			#endif

			#ifdef USE_COORDS1_STREAM
				varying vec2 v_uvs1;
			#endif
			
			#ifdef USE_COLOR_TEXTURE
				uniform sampler2D color_texture;
			#endif

			#ifdef USE_COLOR_CUBEMAP
				uniform samplerCube color_cubemap;
			#endif


			#ifdef USE_OPACITY_TEXTURE
				uniform sampler2D opacity_texture;
			#endif

			#ifdef USE_SPECULAR_TEXTURE
				uniform sampler2D specular_texture;
			#endif

			#ifdef USE_AMBIENT_TEXTURE
				uniform sampler2D ambient_texture;
			#endif

			#ifdef USE_EMISSIVE_TEXTURE
				uniform sampler2D emissive_texture;
			#endif

			#ifdef USE_NORMAL_TEXTURE
				uniform mat4 u_normal_model;
				uniform sampler2D normal_texture;
			#endif
			
			#ifdef USE_BUMP_TEXTURE
				uniform sampler2D bump_texture;
			#endif

			#ifdef USE_BUMP_FACTOR
				uniform float u_bumpmap_factor;
			#endif

			#ifdef USE_NORMALMAP_FACTOR
				uniform float u_normalmap_factor;
			#endif

 			
			#ifdef USE_DETAIL_TEXTURE
				uniform sampler2D detail_texture;
				uniform vec3 u_detail_info;
			#endif

			#ifdef USE_REFLECTIVITY_TEXTURE
				uniform sampler2D reflectivity_texture;
			#endif

			uniform vec2 u_reflection_info;
			#ifdef USE_ENVIRONMENT_TEXTURE
				uniform sampler2D environment_texture;
			#endif

			#ifdef USE_ENVIRONMENT_CUBEMAP
				uniform samplerCube environment_cubemap;
			#endif

			#ifdef USE_IRRADIANCE_TEXTURE
				uniform sampler2D irradiance_texture;
			#endif

			#ifdef USE_IRRADIANCE_CUBEMAP
				uniform samplerCube irradiance_cubemap;
			#endif

			#ifdef USE_PROJECTIVE_LIGHT
				#ifdef USE_PROJECTIVE_LIGHT_CUBEMAP
					uniform samplerCube light_texture;
				#else
					uniform sampler2D light_texture;
				#endif
			#endif

			#ifdef USE_TEXTURE_AVERAGE_LIGHT
				uniform sampler2D light_average_texture;
			#endif

			#ifdef USE_SOFT_PARTICLES
				uniform sampler2D depth_texture;
			#endif

			#ifdef USE_VELVET
				uniform vec4 u_velvet_info;
			#endif

			#ifdef USE_BACKLIGHT
				uniform float u_backlight_factor;
			#endif

			#ifdef USE_LIGHT_OFFSET
				uniform float u_light_offset;
			#endif

			#ifdef USE_BRIGHTNESS_FACTOR
				uniform float u_brightness_factor;
			#endif

			#ifdef USE_COLORCLIP_FACTOR
				uniform float u_colorclip_factor;
			#endif

			uniform vec3 u_background_color;

			uniform vec4 u_material_color;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_emissive_color;

			uniform vec3 u_light_pos;
			uniform vec3 u_light_front;
			uniform vec3 u_light_color;
			uniform vec4 u_light_angle; //start,end,phi,theta
			uniform vec2 u_light_att; //start,end

			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_planes; //far near
			uniform float u_pointSize;

			uniform vec3 u_fog_info;
			uniform vec3 u_fog_color;

			uniform vec2 u_specular;

			uniform vec4 u_clipping_plane;

			#if defined(USE_SHADOW_MAP) || defined(USE_PROJECTIVE_LIGHT)
				varying vec4 v_light_coord;
			#endif

			#ifdef USE_SHADOW_MAP
				#import "testShadow"
			#endif

			#ifdef USE_SPOT_LIGHT
				#import "spotFalloff"
			#endif

			#ifdef USE_TANGENT_NORMALMAP
				#import "perturbNormal"
			#endif

			#ifdef USE_BUMP_TEXTURE
				#import "bumpNormal"
			#endif

			#ifdef USE_PIXEL_SHADER_FUNCTIONS
				USE_PIXEL_SHADER_FUNCTIONS
			#endif

			vec2 polarToCartesian(in vec3 V)
			{
				return vec2( 0.5 - (atan(V.z, V.x) / -6.28318531), asin(V.y) / 1.57079633 * 0.5 + 0.5);
			}
			
			void main() {
				float temp = 0.0;
				vec2 temp_v2 = vec2(0.0);
				vec3 temp_v3 = vec3(0.0);

				#ifdef USE_CLIPPING_PLANE
					if( dot(v_pos, u_clipping_plane.xyz) < u_clipping_plane.w)
						discard;
				#endif
				

				//surface color
				vec3 final_color = vec3(0.0);
				vec3 color = u_material_color.xyz;
				float alpha = u_material_color.a;
				#ifdef USE_COLOR_STREAM
					color *= v_color.xyz;
					alpha *= v_color.w;
				#endif

				float spec_factor = u_specular.x;
				float spec_gloss = u_specular.y;
				float spec_light = 0.0;

				vec3 N = normalize(v_normal);

				//* COMPUTE TEXTURE COORDINATES ***************************
				vec2 uvs_0 = v_uvs;
				vec2 uvs_1 = uvs_0;
				#ifdef USE_COORDS1_STREAM
					uvs_1 = v_uvs1;
				#endif
				vec2 uvs_transformed = v_uvs_transformed;
				vec2 uvs_worldxy = v_pos.xy * 0.1;
				vec2 uvs_worldxz = v_pos.xz * 0.1;
				vec2 uvs_worldyz = v_pos.yz * 0.1;
				vec2 uvs_screen = (v_screenpos.xy / v_screenpos.w) * 0.5 + 0.5;
				vec2 uvs_flipped_screen = vec2(1.0 - uvs_screen.x, uvs_screen.y);

				vec3 prev_norm = N;
				#ifdef USE_NORMAL_TEXTURE
					//warning: v_normal is in World space
					vec3 normalmap_pixel = texture2D( normal_texture, USE_NORMAL_TEXTURE ).xyz;
					#ifdef USE_TANGENT_NORMALMAP
						N = perturbNormal(N, v_pos, USE_NORMAL_TEXTURE, normalmap_pixel );
						//N is in world space
					#else
						N = (normalmap_pixel - vec3(0.5)) * 2.0;
						//N is in object space so we need to convert it to world space
						N = (u_normal_model * vec4(N,1.0)).xyz;
					#endif

					#ifdef USE_NORMALMAP_FACTOR
						N = mix(prev_norm, normalize(N), u_normalmap_factor);
					#endif
					N = normalize(N);
				#endif

				#ifdef USE_BUMP_TEXTURE
					float bump_factor = 1.0;
					#ifdef USE_BUMP_FACTOR
						bump_factor = u_bumpmap_factor;
					#endif
					N = bumpNormal(v_pos, N, bump_texture, USE_BUMP_TEXTURE, bump_factor );
				#endif

				vec3 localPosN = normalize(v_local_pos); //use_polar_vertex

				vec2 uvs_polar = polarToCartesian(N);
				vec2 uvs_polar_reflected = uvs_polar; //computed later when we know the Reflected vector
				vec2 uvs_polar_vertex = polarToCartesian(localPosN);

				//********************************************************

				#ifdef USE_OPACITY_TEXTURE
					alpha *= texture2D(opacity_texture,USE_OPACITY_TEXTURE).x;
				#endif

				#if defined(USE_COLOR_TEXTURE) || defined(USE_COLOR_CUBEMAP)
					vec4 diffuse_tex = vec4(0.0);
					#ifdef USE_COLOR_TEXTURE
						diffuse_tex = texture2D(color_texture, USE_COLOR_TEXTURE );
					#endif
					#ifdef USE_COLOR_CUBEMAP
						diffuse_tex = textureCube(color_cubemap, normalize(v_local_pos) );
					#endif

					color *= diffuse_tex.xyz;
					#ifndef USE_OPACITY_TEXTURE
						alpha *= diffuse_tex.a;
					#endif
				#endif

				/* DEBUG
				#ifdef USE_SHADOW_MAP
					color *= textureCube(shadowmap, normalize(v_pos - u_light_pos)).xyz;
				#endif
				*/

				#ifdef USE_ALPHA_TEST
					if(alpha < USE_ALPHA_TEST)
						discard;
				#endif
				
				#ifdef USE_SPECULAR_TEXTURE
					vec3 spec_tex = texture2D(specular_texture, USE_SPECULAR_TEXTURE ).xyz;
					spec_factor *= spec_tex.x;
					spec_gloss *= spec_tex.y;
				#endif

				#ifdef USE_DETAIL_TEXTURE
					vec3 detail_tex = texture2D(detail_texture,uvs_0 * u_detail_info.yz).xyz;
					color = color + color * (detail_tex - vec3(0.5)) * u_detail_info.x;
				#endif

				//lighting calculation
				#if defined(USE_SHADOW_MAP) && !defined(USE_AMBIENT_ONLY)
					float shadow = 1.0;

					#ifdef USE_HARD_SHADOWS
						shadow = 1.0 - testShadow(vec2(0.,0.));
					#else
						#ifndef USE_SHADOW_CUBEMAP
						if (v_light_coord.w > 0.0) //inside the light frustrum (only apply to frontal lights)
						#endif
						{
							shadow = 2.0 * testShadow(vec2(0.0,0.0));
							shadow += testShadow(vec2(0.0,u_shadow_params.x));
							shadow += testShadow(vec2(0.0,-u_shadow_params.x));
							shadow += testShadow(vec2(-u_shadow_params.x,0.0));
							shadow += testShadow(vec2(u_shadow_params.x,0.0));
							shadow += testShadow(vec2(-u_shadow_params.x,-u_shadow_params.x));
							shadow += testShadow(vec2(u_shadow_params.x,-u_shadow_params.x));
							shadow += testShadow(vec2(-u_shadow_params.x,u_shadow_params.x));
							shadow += testShadow(vec2(u_shadow_params.x,u_shadow_params.x));
							shadow = 1.0 - shadow * 0.1;
						}
					#endif	
				#else
					float shadow = 1.0;
				#endif

				vec3 E = (u_camera_eye - v_pos);
				float cam_dist = length(E);

				#ifdef USE_ORTHOGRAPHIC_CAMERA
					E = normalize(u_camera_eye); //wrong, should be center - eye
				#else
					E /= cam_dist;
				#endif

				vec3 L = (u_light_pos - v_pos);
				float light_dist = length(L);
				L /= light_dist;

				#if defined(USE_SPOT_LIGHT) || defined(USE_DIRECTIONAL_LIGHT)
					L = -u_light_front;
				#endif

				vec3 R = reflect(E,N);
				uvs_polar_reflected = polarToCartesian(-R);

				float NdotL = 1.0;
				#ifdef USE_DIFFUSE_LIGHT
					NdotL = dot(N,L);
				#endif
				float EdotN = dot(E,N); //clamp(dot(E,N),0.0,1.0);
				#ifdef USE_SPECULAR_LIGHT
					spec_light = spec_factor * pow( clamp(dot(R,-L),0.001,1.0), spec_gloss);
				#endif

				vec3 light = vec3(0.0);

				//ambient light
				#ifdef FIRST_PASS
					temp_v3 = u_ambient_color;
					#ifdef USE_AMBIENT_TEXTURE
						temp_v3 *= texture2D(ambient_texture,USE_AMBIENT_TEXTURE).xyz;
					#endif

					#ifdef USE_IRRADIANCE_CUBEMAP
						temp_v3 *= textureCube(irradiance_cubemap,N).xyz;
					#else
						#ifdef USE_IRRADIANCE_TEXTURE
							temp_v3 *= texture2D(irradiance_texture, uvs_polar_reflected ).xyz;
						#endif
					#endif

					light += temp_v3;
				#endif


				float att = 1.0;
				#ifdef USE_LINEAR_ATTENUATION
					att = 100.0 / light_dist;
				#endif

				#ifdef USE_RANGE_ATTENUATION
					if(light_dist >= u_light_att.y)
						att = 0.0;
					else if(light_dist >= u_light_att.x)
						att *= 1.0 - (light_dist - u_light_att.x) / (u_light_att.y - u_light_att.x);
				#endif

				vec3 light_color = u_light_color;
				#ifdef USE_TEXTURE_AVERAGE_LIGHT
					light_color *= texture2D(light_average_texture,vec2(0.5), 12.0).xyz;
				#endif

				#ifdef USE_PROJECTIVE_LIGHT
					#ifdef USE_PROJECTIVE_LIGHT_CUBEMAP
						light_color *= textureCube(light_texture, -L).xyz;
					#else
						vec2 light_sample = (v_light_coord.xy / v_light_coord.w) * vec2(0.5) + vec2(0.5);
						light_color *= texture2D(light_texture,light_sample).xyz;
					#endif

					#ifndef USE_SPOT_CONE
						if (light_sample.x < 0.001 || light_sample.y < 0.001 || light_sample.x > 0.999 || light_sample.y > 0.999)
							att = 0.0;
					#endif
				#endif

				#ifdef USE_SPOT_LIGHT
					#ifdef USE_SPOT_CONE
						att *= spotFalloff(u_light_front, normalize(u_light_pos - v_pos), u_light_angle.z, u_light_angle.w);
					#endif
				#endif

			
				#ifndef USE_AMBIENT_ONLY
					#ifdef USE_LIGHT_OFFSET
						NdotL += u_light_offset;
					#endif

					#ifdef USE_BACKLIGHT
						//if(NdotL > 0.0 != gl_FrontFacing)	NdotL *= u_backlight_factor;
						if(NdotL < 0.0 && gl_FrontFacing)	NdotL *= u_backlight_factor;
					#else
						//if(NdotL > 0.0 != gl_FrontFacing) NdotL = 0.0;
						NdotL = max(0.0, NdotL * (gl_FrontFacing ? 1.0 : 0.0 ));
					#endif

					NdotL = abs(NdotL);
					light += u_diffuse_color * light_color * att * NdotL * shadow; 
				#endif

				//emissive
				temp_v3 = u_emissive_color;
				#ifdef USE_EMISSIVE_TEXTURE
					temp_v3 *= texture2D(emissive_texture,USE_EMISSIVE_TEXTURE).xyz;
				#endif
				#ifndef USE_EMISSIVE_MATERIAL //no idea why
					#ifdef FIRST_PASS
						light += temp_v3;
					#endif
				#endif

				#ifdef USE_IGNORE_LIGHT
					light = vec3(1.0);
				#endif

				//FINAL COLOR ************************* (clamped from 0)
				final_color = max(color * light, vec3(0.0));

				#ifdef USE_EMISSIVE_MATERIAL
					final_color = max(temp_v3,final_color);
				#endif

				float velvet_factor = 0.0;
				#ifdef FIRST_PASS
				#ifdef USE_VELVET
					velvet_factor = pow( 1.0 - abs(EdotN), abs(u_velvet_info.w) );

					#ifdef USE_VELVET_ALPHA
						alpha += velvet_factor;
					#endif

					#ifdef USE_DETAIL_TEXTURE
						velvet_factor += (detail_tex.x - 0.5) * u_detail_info.x;
					#endif

					if(u_velvet_info.w > 0.0)
						final_color += u_velvet_info.xyz * velvet_factor;
					else
						final_color = final_color * (1.0 - velvet_factor) + u_velvet_info.xyz * velvet_factor;

					#ifdef USE_SKIN_SHADER
						spec_factor = pow(spec_factor,velvet_factor);
					#endif
				#endif
				#endif

				//get reflection factor and gloss
				#ifdef USE_REFLECTION
					vec3 reflection_color = u_background_color;

					float reflection_factor = abs(u_reflection_info.x) * pow( 1.0 - clamp(0.0,EdotN,1.0), u_reflection_info.y );
					float reflection_gloss = 0.0;

					#ifdef USE_REFLECTIVITY_TEXTURE
						reflection_factor *= texture2D(reflectivity_texture, USE_REFLECTIVITY_TEXTURE).x;
					#endif

					#ifdef USE_SPECULAR_IN_REFLECTION
						//reflection_factor *= spec_factor;
						reflection_gloss = max(0.0, (20.0 - spec_gloss) / 4.0);
					#endif


					#ifdef FIRST_PASS

					//compute reflection color from environment
					#if defined(USE_ENVIRONMENT_TEXTURE) || defined(USE_ENVIRONMENT_CUBEMAP)

						#ifdef USE_ENVIRONMENT_CUBEMAP
							reflection_color = textureCube(environment_cubemap,-R, reflection_gloss).xyz;
						#endif
						#ifdef USE_ENVIRONMENT_TEXTURE
							temp_v2 = vec2(0.0);
							vec2 env_uv = USE_ENVIRONMENT_TEXTURE ;

							#ifdef USE_NORMAL_TEXTURE
								//temp_v2 += vec2(0.0, -length(normalmap_pixel.xy)) * 0.1; //this can be improved, it is just a hack
								temp_v2 = vec2(0.0,-0.1) * (1.0 - dot(N, normalize(v_normal)));
								#ifdef USE_NORMALMAP_FACTOR
									temp_v2 *= u_normalmap_factor;
								#endif
								env_uv += temp_v2;
							#endif
							reflection_color = texture2D(environment_texture, env_uv, reflection_gloss ).xyz;
						#endif
					#endif //environtment

					//apply reflection

					if( u_reflection_info.x > 0.0 )
						final_color = final_color * max(0.0, 1.0 - reflection_factor) + reflection_color * reflection_factor;
					else
						final_color += reflection_color * reflection_factor;
					#endif //firstpass
				#endif //use_reflection

				//apply spec factor
				#ifndef USE_AMBIENT_ONLY
					#ifdef USE_SPECULAR_ONTOP
						final_color += light_color * max(0.0, att * spec_light * shadow);
					#else
						final_color += color * light_color * max(0.0, att * spec_light * shadow);
					#endif
					#ifdef USE_SPECULAR_ON_ALPHA
						alpha += spec_light;
					#endif
				#endif


				/* TODO
				#ifdef USE_SOFT_PARTICLES
					alpha *= clamp((v_screenpos.z - texture2D(depth_texture,uvs_screen).r),0.0,1.0);
				#endif
				*/

				//apply fog
				#ifdef USE_FOG
					#ifdef USE_FOG_EXP
						float fog = 1. - 1.0 / exp(max(0.0,cam_dist - u_fog_info.x) * u_fog_info.z);
					#elif defined(USE_FOG_EXP2)
						float fog = 1. - 1.0 / exp(pow(max(0.0,cam_dist - u_fog_info.x) * u_fog_info.z,2.0));
					#else
						float fog = 1. - clamp((u_fog_info.y - cam_dist) / (u_fog_info.y - u_fog_info.x),0.,1.);
					#endif
					#ifdef FIRST_PASS
						final_color = mix(final_color, u_fog_color, fog);
					#else
						final_color = mix(final_color, vec3(0.0), fog);
					#endif
				#endif

				#ifdef USE_BRIGHTNESS_FACTOR
					final_color *= u_brightness_factor;
				#endif
				#ifdef USE_COLORCLIP_FACTOR
					final_color -= vec3(u_colorclip_factor);
					/*
					temp = length(final_color);
					if( temp < u_colorclip_factor * 0.75)
						final_color = vec3(0.0);
					else if( temp < u_colorclip_factor)
						final_color *= clamp((temp - u_colorclip_factor * 0.75) / (u_colorclip_factor * 0.25),0.0,1.0);
					*/
				#endif

				gl_FragColor = vec4(final_color, alpha); //regular color

				//gl_FragColor.xyz = v_pos;
				//gl_FragColor = vec4(-E,1.0); //front vector
				//gl_FragColor = vec4(v_pos * 0.005,1.0); //pos vector
				//gl_FragColor = vec4(light,1.0);
			}
		]]>
		</code>
	</shader>

	<shader id="lowglobal" tags="instance" macros="USE_COLOR_TEXTURE,USE_OPACITY_TEXTURE,USE_SPECULAR_TEXTURE,USE_AMBIENT_TEXTURE,USE_EMISSIVE_TEXTURE,USE_ALPHA_TEST,USE_DIRECTIONAL_LIGHT,USE_SPOT_LIGHT,USE_LINEAR_ATTENUATION,USE_DIFFUSE_LIGHT,USE_RANGE_ATTENUATION,USE_AMBIENT_ONLY,USE_VELVET,USE_POINTS,USE_POINT_CLOUD,NO_NORMALS,NO_COORDS,USE_COLOR_STREAM,USE_FOG,USE_CLIPPING_PLANE,USE_TEXTURE_MATRIX,USE_SPOT_CONE,USE_SOFT_PARTICLES,FIRST_PASS,USE_SKINNING,USE_SKINNING_TEXTURE"  multipass="true" imports="true">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;
			attribute vec3 a_vertex;
			varying vec3 v_pos;

			#ifndef NO_NORMALS
				attribute vec3 a_normal;
			#endif

			#ifndef NO_COORDS
				attribute vec2 a_coord;
			#endif

			#ifdef USE_COLOR_STREAM
				attribute vec4 a_color;
				varying vec4 v_color;
			#endif

			#ifdef USE_POINT_CLOUD
				attribute vec2 a_extra2;
			#endif

			#ifdef USE_SKINNING
				#import "skinning"
			#endif				

			uniform vec2 u_specular;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_emissive_color;

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			uniform mat4 u_viewprojection;
			uniform mat4 u_normal_model;
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;


			uniform vec3 u_light_pos;
			uniform vec3 u_light_front;
			uniform vec3 u_light_color;
			uniform vec4 u_light_angle; //start,end,phi,theta
			uniform vec2 u_light_att; //start,end

			varying vec2 v_uvs;
			varying vec3 v_light;
			varying vec4 v_screenpos;

			#ifdef USE_BACKLIGHT
				uniform float u_backlight_factor;
			#endif

			#ifdef USE_LIGHT_OFFSET
				uniform float u_light_offset;
			#endif

			#ifdef USE_VELVET
				uniform vec4 u_velvet_info;
			#endif

			void main() {

				#ifdef NO_NORMALS
					vec3 N = vec3(0.,1.,0.);
				#else
					vec3 N = a_normal;
				#endif

				vec4 vertex4 = vec4(a_vertex,1.0);

				#ifdef USE_SKINNING
					applySkinning(vertex4, N);
				#endif

				N = normalize((u_normal_model * vec4(N,1.0)).xyz);


				//mat4 mvp = (u_viewprojection * u_model);
				gl_Position =  u_mvp * vertex4;
				v_pos = (u_model * vertex4).xyz;
				v_screenpos = gl_Position;

				float spec_factor = u_specular.x;
				float spec_gloss = u_specular.y;

				vec3 E = (u_camera_eye - v_pos);
				float cam_dist = length(E);

				#ifdef USE_ORTHOGRAPHIC_CAMERA
					E = normalize(u_camera_eye);
				#else
					E /= cam_dist;
				#endif

				vec3 L = (u_light_pos - v_pos);
				float light_dist = length(L);
				L /= light_dist;

				float att = 1.0;
				#ifdef USE_LINEAR_ATTENUATION
					att = 100.0 / light_dist;
				#endif

				#ifdef USE_RANGE_ATTENUATION
					if(light_dist >= u_light_att.y)
						att = 0.0;
					else if(light_dist >= u_light_att.x)
						att *= 1.0 - (light_dist - u_light_att.x) / (u_light_att.y - u_light_att.x);
				#endif

				#if defined(USE_SPOT_LIGHT) || defined(USE_DIRECTIONAL_LIGHT)
					L = -u_light_front;
				#endif

				vec3 R = reflect(E,N);
				float NdotL = 1.0;
				#ifdef USE_DIFFUSE_LIGHT
					NdotL = dot(N,L);
				#endif
				float EdotN = dot(E,N); //clamp(dot(E,N),0.0,1.0);
				spec_factor *= pow( clamp(dot(R,-L),0.001,1.0), spec_gloss);

				#ifdef FIRST_PASS
				vec3 light = u_ambient_color;
				#else
				vec3 light = vec3(0.0);
				#endif

				#ifndef USE_AMBIENT_ONLY
					#ifdef USE_LIGHT_OFFSET
						NdotL += u_light_offset;
					#endif

					NdotL = clamp(NdotL,0.0,1.0);
					light += u_diffuse_color * u_light_color * att * NdotL; 
					light += u_light_color * (att * spec_factor);
				#endif

				light += u_emissive_color;

				float velvet_factor = 0.0;
				#ifdef USE_VELVET
					velvet_factor = pow( 1.0 - abs(EdotN), abs(u_velvet_info.w) );

					if(u_velvet_info.w > 0.0)
						light += u_velvet_info.xyz * velvet_factor;
					else
						light = light * (1.0 - velvet_factor) + u_velvet_info.xyz * velvet_factor;
				#endif

				//STREAMS **************************
				#ifdef USE_COLOR_STREAM
					v_color = a_color;
				#endif

				#ifdef NO_COORDS
					v_uvs = vec2(0.5,0.5);
				#else
					v_uvs = a_coord;
				#endif

				v_light = light;

				gl_PointSize = (u_pointSize / length(u_camera_eye - v_pos)) * u_camera_perspective.y; 

				#ifdef USE_POINT_CLOUD
					gl_PointSize = (u_pointSize * a_extra2.x / length(u_camera_eye - v_pos)) * u_camera_perspective.y;
				#endif

			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec4 v_screenpos;
			varying vec2 v_uvs;
			#ifdef USE_COLOR_STREAM
				varying vec4 v_color;
			#endif
			varying vec3 v_light;

			#ifdef USE_COLOR_TEXTURE
				uniform sampler2D color_texture;
			#endif

			#ifdef USE_OPACITY_TEXTURE
				uniform sampler2D opacity_texture;
			#endif

			#ifdef USE_SOFT_PARTICLES
				uniform sampler2D depth_texture;
			#endif

			uniform vec4 u_clipping_plane;
			uniform vec4 u_material_color;
			uniform vec2 u_camera_planes; //far near

			//for soft particles...
			float LinearDepth(float z)
			{
				float n = u_camera_planes.x;
				float f = u_camera_planes.y;
				return (2.0 * n) / (f + n - z * (f - n));
			}

			void main() {

				#ifdef USE_CLIPPING_PLANE
					if( dot(v_pos, u_clipping_plane.xyz) < u_clipping_plane.w)
						discard;
				#endif
				
				vec2 uvs = v_uvs;
				#ifdef USE_POINT_CLOUD
					uvs = gl_PointCoord.st;
					uvs.y = 1.0 - uvs.y;
				#endif


				vec2 uvs_screen = (v_screenpos.xy / v_screenpos.w) * 0.5 + 0.5;
				vec2 uvs_flipped_screen = vec2(1.0 - uvs_screen.x, uvs_screen.y);

				vec3 final_color = u_material_color.xyz;
				float alpha = u_material_color.a;
				#ifdef USE_COLOR_STREAM
					final_color *= v_color.xyz;
					alpha *= v_color.a;
				#endif

				#ifdef USE_OPACITY_TEXTURE
					alpha *= texture2D(opacity_texture,uvs).x;
				#endif

				#ifdef USE_COLOR_TEXTURE
					vec4 diffuse_tex = texture2D(color_texture,uvs);
					final_color *= diffuse_tex.xyz;
					#ifndef USE_OPACITY_TEXTURE
						alpha *= diffuse_tex.a;
					#endif
				#endif

				#ifdef USE_SOFT_PARTICLES
					float depth = ((v_screenpos.z / v_screenpos.w));
					float texDepth = LinearDepth(texture2D(depth_texture,uvs_screen).x) - 0.5;
					alpha *= clamp((texDepth - depth) * 5.,0.0,1.0);
				#endif

				#ifdef USE_ALPHA_TEST
					if(alpha < USE_ALPHA_TEST)
						discard;
				#endif

				//apply light
				final_color *= v_light;

				#ifdef USE_BRIGHTNESS_FACTOR
					final_color *= u_brightness_factor;
				#endif

				gl_FragColor = vec4(final_color, alpha); //regular color
			}
		]]>
		</code>
	</shader>

	<shader id="depth" tags="" macros="NO_COORDS,USE_ORTHOGRAPHIC_CAMERA,USE_COLOR_TEXTURE,USE_OPACITY_TEXTURE,USE_ALPHA_TEST,USE_LINEAR_DISTANCE,USE_VERTEX_SHADER_UNIFORMS,USE_VERTEX_SHADER_FUNCTIONS,USE_VERTEX_SHADER_CODE,USE_SKINNING,USE_SKINNING_TEXTURE" imports="true">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;

			#ifdef USE_ALPHA_TEST
				#ifndef NO_COORDS
					attribute vec2 a_coord;
					varying vec2 v_uvs;
					uniform mat3 u_texture_matrix;
					varying vec2 v_uvs_transformed;
				#endif
			#endif

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;
			varying vec4 pos;
			varying vec3 world_pos;


			#ifdef USE_SKINNING
				#import "skinning"
			#endif

			#ifdef USE_VERTEX_SHADER_UNIFORMS
				USE_VERTEX_SHADER_UNIFORMS
			#endif

			#ifdef USE_VERTEX_SHADER_FUNCTIONS
				USE_VERTEX_SHADER_FUNCTIONS
			#endif

			void main()
			{
				#ifdef USE_ALPHA_TEST
					#ifndef NO_COORDS
						v_uvs = a_coord;
					#else
						v_uvs = vec2(0.5,0.5);
					#endif
				#endif

				#ifdef USE_ALPHA_TEST
					v_uvs_transformed = (u_texture_matrix * vec3(v_uvs,1.0)).xy;
				#endif

				vec4 vertex4 = vec4(a_vertex,1.0);

				vec3 v_normal; //not used but needed in case the deformer affects it

				#ifdef USE_SKINNING
					applySkinning(vertex4, v_normal);
				#endif	

				#ifdef USE_VERTEX_SHADER_CODE
					USE_VERTEX_SHADER_CODE
				#endif

				world_pos = (u_model * vertex4).xyz;

				gl_Position = pos = u_mvp * vertex4;

				#ifdef USE_ORTHOGRAPHIC_CAMERA
					gl_PointSize = u_pointSize; 
				#else
					gl_PointSize = (u_pointSize / length(u_camera_eye - world_pos)) * u_camera_perspective.y; 
				#endif
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec4 pos; //screen space

			#ifdef USE_ALPHA_TEST
				#ifdef USE_COLOR_TEXTURE
					uniform sampler2D color_texture;
				#endif
				#ifdef USE_OPACITY_TEXTURE
					uniform sampler2D opacity_texture;
				#endif
				
				uniform vec4 u_material_color; //for the alpha

				varying vec2 v_uvs;
				varying vec2 v_uvs_transformed;
			#endif

			#ifdef USE_LINEAR_DISTANCE
				varying vec3 world_pos;				
				uniform vec3 u_camera_eye; //camera position
			#endif
			uniform vec2 u_camera_planes; //far near			

			//packs depth normalized 
			vec4 PackDepth32(float depth)
			{
				const vec4 bitSh  = vec4(   256*256*256, 256*256,   256,         1);
				const vec4 bitMsk = vec4(   0,      1.0/256.0,    1.0/256.0,    1.0/256.0);
				vec4 comp;
				comp	= depth * bitSh;
				comp	= fract(comp);
				comp	-= comp.xxyz * bitMsk;
				return comp;
			}

			void main() {

				#ifdef USE_ALPHA_TEST
					vec2 uvs_0 = v_uvs;
					vec2 uvs_1 = uvs_0;
					vec2 uvs_transformed = v_uvs_transformed;
					vec2 uvs_worldxy = uvs_0;//v_pos.xy * 0.1;
					vec2 uvs_worldxz = uvs_0;//v_pos.xz * 0.1;
					vec2 uvs_worldyz = uvs_0;//v_pos.yz * 0.1;
					vec2 uvs_screen = uvs_0;//(v_screenpos.xy / v_screenpos.w) * 0.5 + 0.5;
					vec2 uvs_flipped_screen = vec2(1.0 - uvs_screen.x, uvs_screen.y);

					float alpha = u_material_color.w;
					#ifdef USE_COLOR_TEXTURE
						alpha *= texture2D(color_texture,USE_COLOR_TEXTURE).w;
					#endif
					#ifdef USE_OPACITY_TEXTURE
						alpha *= texture2D(opacity_texture,USE_OPACITY_TEXTURE).x;
					#endif
					if(alpha < USE_ALPHA_TEST)
						discard;
				#endif

				float depth = 0.0;

				#ifdef USE_LINEAR_DISTANCE				
					depth = (length(world_pos - u_camera_eye) - u_camera_planes.x) / (u_camera_planes.y - u_camera_planes.x);
					//depth = length(world_pos - u_camera_eye);
				#else
					depth = (pos.z / pos.w) * 0.5 + 0.5; //normalize
				#endif

				gl_FragColor = PackDepth32(depth);
				//gl_FragColor = vec4(1.0,0.0,0.0,0.0); //debug

				//gl_FragColor = vec4( PackDepth32(depth), 0.0);
			}
		]]>
		</code>
	</shader>

	<shader id="depth_linear" tags="POSTFX">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			uniform mat4 u_mvp;

			varying vec4 pos;
			void main()
			{
				gl_Position = pos = u_mvp * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			vec4 PackDepth32( float v ) {
			  vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
			  enc = fract(enc);
			  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
			  return enc;
			}

			varying vec4 pos;
			void main() {
				float depth = pos.z / pos.w;
				gl_FragColor = PackDepth32(depth);

				//gl_FragColor = PackDepth32(depth * 0.5 + 0.5);
				//gl_FragColor = vec4( PackDepth32(depth), 0.0);
			}
		]]>
		</code>
	</shader>

	<shader id="cell_outline" tags="instance">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			uniform mat4 u_mvp;

			varying vec2 v_uvs;
			uniform float u_extra_factor;

			void main() {
				vec3 normal = a_normal;
				gl_Position = u_mvp * (vec4(a_vertex,1.0) + vec4(normal * u_extra_factor,0.0));
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			uniform vec4 u_material_color;

			void main() {
				gl_FragColor = u_material_color;
			}
		]]>
		</code>
	</shader>

	<shader id="flat_texture" tags="instance">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			uniform mat4 u_mvp;

			varying vec2 v_uvs;

			void main() {
				v_uvs = a_coord;
				vec4 vertex4 = vec4(a_vertex,1.0);
				gl_Position = u_mvp * vertex4;
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			uniform vec4 u_material_color;
			varying vec2 v_uvs;
			uniform sampler2D color_texture;

			void main() {
				gl_FragColor = u_material_color * texture2D(color_texture,v_uvs);
			}
		]]>
		</code>
	</shader>

	<shader id="normal" tags="debug,instance" macros="USE_NORMAL_TEXTURE,USE_NORMALMAP_FACTOR,USE_TANGENT_NORMALMAP" imports="true">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;

			uniform mat4 u_mvp;
			uniform mat4 u_model;
			uniform mat4 u_normal_model;

			#ifdef USE_NORMAL_TEXTURE
				varying vec2 v_uvs;
				attribute vec2 a_coord;
			#endif

			varying vec3 v_pos;
			varying vec3 v_normal;

			void main() 
			{
				#ifdef USE_NORMAL_TEXTURE
					v_uvs = a_coord;
				#endif

				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
				gl_Position = u_mvp * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;

			uniform mat4 u_normal_model;

			#ifdef USE_NORMALMAP_FACTOR
				uniform float u_normalmap_factor;
			#endif

			#ifdef USE_NORMAL_TEXTURE
				uniform sampler2D normal_texture;
				varying vec2 v_uvs;
			#endif

			#ifdef USE_TANGENT_NORMALMAP
				#import "perturbNormal"
			#endif

			void main() {

				vec3 N = v_normal;
				vec3 prev_norm =  normalize(N);

				#ifdef USE_NORMAL_TEXTURE
					//warning: v_normal is in World space
					vec3 normalmap_pixel = texture2D( normal_texture, v_uvs ).xyz;
					#ifdef USE_TANGENT_NORMALMAP
						N = perturbNormal(prev_norm, v_pos, v_uvs, normalmap_pixel );
					#else
						N = (normalmap_pixel - vec3(0.5)) * 2.0;
						//N is in object space so we need to convert it to world space
						N = (u_normal_model * vec4(N,1.0)).xyz;
					#endif

					#ifdef USE_NORMALMAP_FACTOR
						N = mix(prev_norm, normalize(N), u_normalmap_factor);
					#endif
				#else
					N = prev_norm;
				#endif

				gl_FragColor = vec4(N, 1.0);
			}
		]]>
		</code>
	</shader>

	<shader id="phong" tags="instance" macros="USE_SPOT_LIGHT,USE_DIRECTIONAL_LIGHT,USE_AMBIENT_ONLY">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			uniform mat4 u_mvp;

			uniform mat4 u_model;
			uniform mat4 u_normal_model;
			varying vec3 v_pos;
			varying vec3 v_normal;
			
			void main() {
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				gl_Position = u_mvp * vec4(a_vertex,1.0);

				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			uniform vec4 u_material_color;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_light_pos;
			uniform vec3 u_light_front;

			void main() {
				#ifdef USE_AMBIENT_ONLY
					vec3 color = u_material_color.xyz * u_ambient_color;
				#else
					vec3 L = normalize(u_light_pos - v_pos);
					#if defined(USE_SPOT_LIGHT) || defined(USE_DIRECTIONAL_LIGHT)
						L = u_light_front;
					#endif

					vec3 N = normalize(v_normal);
					vec3 light = vec3(1.0) * clamp(0.0,dot(N,L),1.0);
					vec3 color = u_material_color.xyz * (light * u_diffuse_color + u_ambient_color);
				#endif

				gl_FragColor = vec4(color.x, color.y, color.z, u_material_color.a);
			}
		]]>
		</code>
	</shader>

	<shader id="debug" tags="instance,debug">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;
			uniform mat4 u_mvp;

			varying vec2 v_uvs;
			varying vec3 v_normal;
			uniform mat4 u_normal_model;

			void main() {
				v_uvs = a_coord;
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;

				gl_Position = u_mvp * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			uniform vec4 u_material_color;
			varying vec2 v_uvs;
			uniform samplerCube color_texture;
			varying vec3 v_normal;

			void main() {
				gl_FragColor = u_material_color * textureCube(color_texture,v_normal);
			}
		]]>
		</code>
	</shader>

	<shader id="phong_texture" tags="instance" macros="USE_SPOT_LIGHT,USE_DIRECTIONAL_LIGHT,USE_AMBIENT_ONLY">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;
			uniform mat4 u_mvp;

			uniform mat4 u_model;
			uniform mat4 u_normal_model;
			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_coord;
			
			void main() {
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				gl_Position = u_mvp * vec4(a_vertex,1.0);
				v_coord = a_coord;
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_coord;

			uniform sampler2D color_texture;
			uniform vec4 u_material_color;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_light_color;
			uniform vec3 u_light_pos;
			uniform vec3 u_light_front;

			void main() {
				#ifdef USE_AMBIENT_ONLY
					vec3 color = u_material_color.xyz * u_ambient_color;
				#else
					vec3 L = normalize(u_light_pos - v_pos);
					#if defined(USE_SPOT_LIGHT) || defined(USE_DIRECTIONAL_LIGHT)
						L = u_light_front;
					#endif

					vec3 N = normalize(v_normal);
					vec3 light = u_light_color * max(0.0,dot(N,L));
					vec3 color = u_material_color.xyz * (light * u_diffuse_color + u_ambient_color);
				#endif

				gl_FragColor = vec4(color, u_material_color.a) * texture2D( color_texture, v_coord );
			}
		]]>
		</code>
	</shader>

	<shader id="flat" tags="instance" macros="USE_ORTHOGRAPHIC_CAMERA">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			uniform mat4 u_model;
			uniform mat4 u_mvp;
			uniform vec3 u_camera_eye;
			uniform vec2 u_camera_perspective;
			uniform float u_pointSize;

			void main() {
				vec4 vertex4 = vec4(a_vertex,1.0);
				//skinning?
				//TODO

				gl_Position = u_mvp * vertex4;
				vec3 v_pos = (u_model * vertex4).xyz;
				#ifdef USE_ORTHOGRAPHIC_CAMERA
					gl_PointSize = u_pointSize; 
				#else
					gl_PointSize = (u_pointSize / length(u_camera_eye - v_pos)) * u_camera_perspective.y; 
				#endif			
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			uniform vec4 u_material_color;
			void main() {
			  gl_FragColor = vec4(u_material_color);
			}
		]]>
		</code>
	</shader>

	<shader id="phong_shadow" tags="instance">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			uniform mat4 u_mvp;

			uniform mat4 u_model;
			uniform mat4 u_normal_model;
			uniform mat4 u_lightMatrix;
			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec4 v_light_coord;
			
			void main() {
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
				gl_Position = u_mvp * vec4(a_vertex,1.0);
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				v_light_coord = (u_lightMatrix) * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec4 v_light_coord;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_lightpos;
			uniform sampler2D shadowmap;
			
			float UnpackDepth24(vec3 depth)
			{
				return dot(vec3(65536.0, 256.0, 1.0), depth);
			}
			float testShadow(vec2 offset)
			{
				vec2 sample = (v_light_coord.xy / v_light_coord.w) * 0.5 + vec2(0.5,0.5) + offset;
				float shadow = 0.0;
				if (v_light_coord.w > 0.0) {
					float depth = 0.0;
					if (clamp(sample, 0.0, 1.0) == sample) {
						/*float sampleDepth = texture2D(shadowmap, sample).r;*/
						float sampleDepth = UnpackDepth24( texture2D(shadowmap, sample).xyz );
						depth = (sampleDepth == 1.0) ? 1.0e9 : sampleDepth;
					}
					if (depth > 0.0) {
						float bias = -0.01;
						shadow = clamp(300.0 * (bias + v_light_coord.z / v_light_coord.w * 0.5 + 0.5 - depth), 0.0, 1.0);
					}
				}
				return shadow;
			}
			
			void main() {
				float shadow = 2.0 * testShadow(vec2(0.0,0.0));
				shadow += testShadow(vec2(0.0,0.001));
				shadow += testShadow(vec2(0.0,-0.001));
				shadow += testShadow(vec2(-0.001,0.0));
				shadow += testShadow(vec2(0.001,0.0));
				shadow += testShadow(vec2(-0.001,-0.001));
				shadow += testShadow(vec2(+0.001,-0.001));
				shadow += testShadow(vec2(-0.001,+0.001));
				shadow += testShadow(vec2(+0.001,+0.001));
				shadow *= 0.1;
				vec3 L = normalize(u_lightpos - v_pos);
				vec3 N = normalize(v_normal);
				vec3 color = vec3(1.0,1.0,1.0) * clamp(0.0,dot(N,L),1.0) * (1.0 - shadow);
				color += vec3(0.4,0.8,1.0) * clamp(0.0,dot(-N,L),1.0) * 0.5;
				color = color * u_diffuse_color + u_ambient_color;
				gl_FragColor = vec4(color.x, color.y, color.z, 1.0);
				/*gl_FragColor = vec4(1.0,0.7,1.0,1.0) * texture2D(shadowmap, v_light_coord.xy / v_light_coord.w * 0.5 + 0.5).r;*/
				/*gl_FragColor = vec4(1.0,1.0,1.0,1.0) * shadow;*/
			}
		]]>
		</code>
	</shader>

	<shader id="texture" tags="instance">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;
			uniform mat4 u_mvp;

			uniform mat4 u_model;
			uniform mat4 u_normal_model;
			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			
			void main()
			{
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
				v_uvs = a_coord;
				gl_Position = u_mvp * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			uniform sampler2D color_texture;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_lightpos;
			void main()
			{
				vec3 tex = texture2D(color_texture,v_uvs).xyz;
				vec3 L = normalize(u_lightpos - v_pos);
				vec3 N = normalize(v_normal);
				vec3 color = vec3(1.0,1.0,1.0) * clamp(0.0,dot(N,L),1.0);
				color += vec3(0.4,0.8,1.0) * clamp(0.0,dot(-N,L),1.0) * 0.6;
				color = color * u_diffuse_color + u_ambient_color;
				color *= tex;
				gl_FragColor = vec4(color.x, color.y, color.z, 1.0);
			}
		]]>
		</code>
	</shader>

	<shader id="texture_shadow" tags="instance">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;
			uniform mat4 u_mvp;

			uniform mat4 u_model;
			uniform mat4 u_viewprojection;
			uniform mat4 u_normal_model;
			uniform mat4 u_lightMatrix;
			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			varying vec4 v_light_coord;
			
			void main() {
				v_normal = (u_normal_model * vec4(a_normal,1.0)).xyz;
				gl_Position = u_mvp * vec4(a_vertex,1.0);
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
				v_uvs = a_coord;
				v_light_coord = (u_lightMatrix) * vec4(a_vertex,1.0);
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;

			varying vec3 v_pos;
			varying vec3 v_normal;
			varying vec2 v_uvs;
			uniform sampler2D color_texture;
			varying vec4 v_light_coord;
			uniform vec3 u_ambient_color;
			uniform vec3 u_diffuse_color;
			uniform vec3 u_lightpos;
			uniform sampler2D shadowmap;
			
			float UnpackDepth24(vec3 depth)
			{
				return dot(vec3(65536.0, 256.0, 1.0), depth);
			}
			float testShadow(vec2 offset)
			{
				vec2 sample = (v_light_coord.xy / v_light_coord.w) * 0.5 + vec2(0.5,0.5) + offset;
				float shadow = 0.0;
				if (v_light_coord.w > 0.0) {
					float depth = 0.0;
					if (clamp(sample, 0.0, 1.0) == sample) {
						/*float sampleDepth = texture2D(shadowmap, sample).r;*/
						float sampleDepth = UnpackDepth24( texture2D(shadowmap, sample).xyz );
						depth = (sampleDepth == 1.0) ? 1.0e9 : sampleDepth;
					}
					if (depth > 0.0) {
						float bias = -0.01;
						shadow = clamp(300.0 * (bias + v_light_coord.z / v_light_coord.w * 0.5 + 0.5 - depth), 0.0, 1.0);
					}
				}
				return shadow;
			}
			
			void main() {
				float shadow = 2.0 * testShadow(vec2(0.0,0.0));
				shadow += testShadow(vec2(0.0,0.001));
				shadow += testShadow(vec2(0.0,-0.001));
				shadow += testShadow(vec2(-0.001,0.0));
				shadow += testShadow(vec2(0.001,0.0));
				shadow += testShadow(vec2(-0.001,-0.001));
				shadow += testShadow(vec2(+0.001,-0.001));
				shadow += testShadow(vec2(-0.001,+0.001));
				shadow += testShadow(vec2(+0.001,+0.001));
				shadow *= 0.1;
				vec3 tex = texture2D(color_texture,v_uvs).xyz;
				vec3 L = normalize(u_lightpos - v_pos);
				vec3 N = normalize(v_normal);
				vec3 color = vec3(1.0,1.0,1.0) * clamp(0.0,dot(N,L),1.0) * (1.0 - shadow);
				color += vec3(0.4,0.8,1.0) * clamp(0.0,dot(-N,L),1.0) * 0.5;
				color = color * u_diffuse_color + u_ambient_color;
				color *= tex;
				gl_FragColor = vec4(color.x, color.y, color.z, 1.0);
				/*gl_FragColor = vec4(1.0,0.7,1.0,1.0) * texture2D(shadowmap, v_light_coord.xy / v_light_coord.w * 0.5 + 0.5).r;*/ 
				/*gl_FragColor = vec4(1.0,1.0,1.0,1.0) * shadow;*/
			}
		]]>
		</code>
	</shader>

	<shader id="volumetric_light" tags="">
		<code type="vertex_shader">
		<![CDATA[
			precision highp float;

			attribute vec3 a_vertex;
			varying vec3 v_pos;

			uniform mat4 u_model;
			uniform mat4 u_mvp;

			void main() {
				gl_Position = u_mvp * vec4(a_vertex,1.0);
				v_pos = (u_model * vec4(a_vertex,1.0)).xyz;
			}
		]]>
		</code>
		<code type="pixel_shader">
		<![CDATA[
			precision highp float;
			varying vec3 v_pos;

			uniform vec4 u_material_color;
			uniform vec3 u_camera_eye;
			uniform vec4 u_volume_info;
			uniform float u_volume_density;

			bool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, in float tm, out float t, out float tw, out float dist_to_center )
			{
				bool  r = false;
				vec3  d = ro - sp.xyz;
				float b = dot(rd,d);
				float c = dot(d,d) - sp.w*sp.w;
				t = b*b-c;
				if( t > 0.0 )
				{
					t = -b-sqrt(t);
					tw = abs((-b+sqrt(t)) - t);
					r = (t > 0.0) && (t < tm);
				}
				dist_to_center = b;

				return r;
			}

			void main() {
				vec3 rd = normalize( v_pos - u_camera_eye );
				float t = 0.0;
				float tw = 0.0;
				float dist = 0.0;
				if( !intSphere( u_volume_info, u_camera_eye, rd, 10000.0, t, tw, dist) )
					discard;
				float falloff = pow(tw * 0.01 * u_volume_density,2.0);
				//falloff *= 1.0 - dist / u_volume_info.w;
				gl_FragColor = vec4( u_material_color.xyz * falloff, u_material_color.a * falloff);
			}
		]]>
		</code>
	</shader>


	<shader id="screen" tags="">
		<code type="vertex_shader">
			precision highp float;

			attribute vec3 a_vertex;
			attribute vec2 a_coord;

			varying vec2 coord;

			void main() {
				coord = a_coord;
				gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;

			void main() {
				gl_FragColor = texture2D(texture, coord) * color;
			}
		</code>
	</shader>

	<shader id="colorFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform float u_red;
			uniform float u_blue;
			uniform float u_green;

			void main() {
				gl_FragColor = texture2D(texture, coord) * color * vec4(u_red,u_green,u_blue,1.0);
			}
		</code>
	</shader>

	<shader id="contrastFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform float u_contrast;
			uniform float u_brightness;

			void main() {
				vec4 final = texture2D(texture, coord) * u_brightness;
				vec3 diff = final.xyz - vec3(0.5);
				final = vec4(vec3(0.5) + diff * (1.0 + u_contrast), final.a);
				gl_FragColor = final * color;
			}
		</code>
	</shader>

	<shader id="hueFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform float u_hue;
			uniform float u_saturation;

			const mat3 rgb2yiq = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
			const mat3 yiq2rgb = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.1070, 1.7046);

			void main() {
				vec4 final = texture2D(texture, coord);
				vec3 yColor = rgb2yiq * final.xyz;

				float originalHue = atan(yColor.b, yColor.g);
				float finalHue = originalHue + u_hue * 2.0 * 3.141592653589;
				float chroma = sqrt(yColor.b*yColor.b+yColor.g*yColor.g);

				vec3 yFinalColor = vec3(yColor.r, chroma * cos(finalHue), chroma * sin(finalHue));

				yFinalColor = yiq2rgb * yFinalColor;
				float lum = yFinalColor.r * 0.333 + yFinalColor.g * 0.333 + yFinalColor.b * 0.333;
				yFinalColor = mix(vec3(lum),yFinalColor,u_saturation);

				gl_FragColor = vec4(yFinalColor, final.a) * color;
			}
		</code>
	</shader>

	<shader id="curvesFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;

			uniform sampler2D u_curves;

			void main() {
				vec4 final = texture2D(texture, coord);
				final.r = texture2D(u_curves, vec2(final.r,0.0) ).r;
				final.g = texture2D(u_curves, vec2(final.g,0.0) ).g;
				final.b = texture2D(u_curves, vec2(final.b,0.0) ).b;
				gl_FragColor = final * color;
			}
		</code>
	</shader>

	<shader id="glowFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;

			void main() {
				vec4 final = texture2D(texture, coord) + texture2D(texture, coord,3.0) * 0.6;
				gl_FragColor = final;
			}
		</code>
	</shader>

	<shader id="bwFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform float u_threshold;

			void main() {
				vec4 final = texture2D(texture, coord);
				if(final.x + final.y + final.z > (1.0 + u_threshold))
					gl_FragColor = color;
				else
					gl_FragColor = vec4(0.0);
			}
		</code>
	</shader>

	<shader id="lensFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 v_coord;
			void main() {
				v_coord = a_coord; gl_Position = vec4(a_coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 v_coord;
			uniform vec4 color;

			void main() {
				vec2 coord = v_coord;

				float corner_factor = 1.0 - abs(sin(coord.x*3.1415)*sin(coord.y*3.1415));
				float df = 1. / 512.;
				float aberration_factor = 3.0;
				float distortion_factor = 0.75;
				coord = (distortion_factor*(coord - vec2(0.5,0.5))) / (1.0 - corner_factor * (1.0 - distortion_factor)) + vec2(0.5,0.5);

				vec4 final = texture2D(texture, coord, corner_factor * 2.0);
				vec3 c = final.xyz * vec3(0.0,1.0,0.0);
				c += texture2D(texture, coord - vec2(df * aberration_factor * (corner_factor),0.), corner_factor * 2.0 ).xyz * vec3(0.5,0.0,0.0);
				c += texture2D(texture, coord + vec2(df * aberration_factor * (corner_factor),0.), corner_factor * 2.0 ).xyz * vec3(0.0,0.0,0.5);
				c += texture2D(texture, coord - vec2(0., df * aberration_factor * (corner_factor)), corner_factor * 2.0 ).xyz * vec3(0.5,0.0,0.0);
				c += texture2D(texture, coord + vec2(0., df * aberration_factor * (corner_factor)), corner_factor * 2.0 ).xyz * vec3(0.0,0.0,0.5);
				c *= 0.5 + 0.5 * (1.0 - corner_factor);
				gl_FragColor = vec4(c,final.a) * color;
			}
		</code>
	</shader>

	<shader id="tvFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>

		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;

			void main() {
				float corner_factor = 1.0 - abs(sin(coord.x*3.1415)*sin(coord.y*3.1415));
				float df = 1. / 512.;
				float aberration_factor = 3.0;
				vec4 final = texture2D(texture, coord, corner_factor * 2.0);
				vec3 c = final.xyz * vec3(0.0,1.0,0.0);
				c += texture2D(texture, coord - vec2(df * aberration_factor * (corner_factor),0.) ).xyz * vec3(1.0,0.0,0.0);
				c += texture2D(texture, coord + vec2(df * aberration_factor * (corner_factor),0.) ).xyz * vec3(0.0,0.0,1.0);
				c *= 0.5 + 0.5 * (1.0 - corner_factor);
				gl_FragColor = vec4(c,final.a) * color;
			}
		</code>
	</shader>

	<shader id="8bitsFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;
			uniform float time;

			void main() {
				vec3 color;
				float size = 0.1;
				vec2 p = vec2(ivec2(coord * texSize / size)) + 0.5 + 1.0 / size;
				color = floor(((texture2D(texture, p / texSize * size).rgb - 0.5) * 1.6 + 0.8) * 2.0) / 2.0;
				gl_FragColor = vec4(color, 1.0);
			}
		</code>
	</shader>

	<shader id="instagramFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;
			uniform float time;

			const vec3 offset = vec3(0.22, 0.07, 0.28);
			const vec3 haze = vec3(1.0, 0.78, 0.24);

			void main() {
				vec3 color = texture2D(texture, coord).rgb;
				color = min(color * haze * 1.3, haze);
				color += offset * (1.0 - color);
				gl_FragColor = vec4(1.0 - (1.0 - color), 1.0);
			}
		</code>
	</shader>

	<shader id="edgesFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			<![CDATA[
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;
			uniform float time;

			const vec2 size = vec2(1.0/512.0,1.0/512.0);
			void main() {
				float big = 0.0, small = 0.0, c;
				for (float x = -1.0; x <= 1.0; x += 1.0) {
					for (float y = -1.0; y <= 1.0; y += 1.0) {
						c = texture2D(texture, coord + size * vec2(x, y)).g;
						big += c;
						if (x == 0.0 || y == 0.0) {
							small += c;
						}
					}
				}
				float edge = max(0.0, big / 9.0 - small / 5.0);
				gl_FragColor = vec4(max(vec3(0.0), texture2D(texture, coord).rgb - (edge * edge * 4000.0)), 1.0);
			}
			]]>
		</code>
	</shader>

	<shader id="edgesDepthFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			<![CDATA[
			precision highp float;

			uniform sampler2D texture;
			uniform sampler2D depth;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;
			uniform vec2 camera_planes;
			uniform float time;
			uniform float u_threshold;

			vec2 size = vec2(1.0/texSize.x,1.0/texSize.y);

			float LinearDepth(vec2 uv)
			{
				float n = camera_planes.x;
				float f = camera_planes.y;
				return (2.0 * n) / (f + n - texture2D(depth, uv).x * (f - n));
			}

			void main() {
				float big = 0.0, small = 0.0, c;
				for (float x = -1.0; x <= 1.0; x += 1.0) {
					for (float y = -1.0; y <= 1.0; y += 1.0) {
						c = LinearDepth(coord + size * vec2(x, y));
						big += c;
						if (x == 0.0 && y == 0.0) {
							small += c;
						}
					}
				}
				float edge = max(0.0, big / 9.0 - small ) * 100.0 * u_threshold;
				gl_FragColor = vec4(max(vec3(0.0), texture2D(texture, coord).rgb - (edge * edge * 4000.0)), 1.0);
			}
			]]>
		</code>
	</shader>

	<shader id="DOFFX" tags="fx">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			<![CDATA[
			precision highp float;

			uniform sampler2D texture;
			uniform sampler2D depth;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;
			uniform float time;
			uniform vec2 camera_planes;

			uniform float u_focus_distance;
			uniform float u_focus_range;
			uniform float u_max_blur;

			float LinearDepth()
			{
				float n = camera_planes.x;
				float f = camera_planes.y;
				return (2.0 * n) / (f + n - texture2D(depth, coord).x * (f - n));
			}

			void main() {
				//float diff = abs(u_focus_distance - texture2D(depth, coord).x );
				float diff = abs(LinearDepth() * camera_planes.y - u_focus_distance);
				float dof = 1.0;
				if(diff <= u_focus_range)
					dof = diff / u_focus_range;
				//gl_FragColor = vec4(dof,dof,dof,1.0);
				//return;

				gl_FragColor = texture2D(texture, coord, dof * u_max_blur ).rgba;
			}
			]]>
		</code>
	</shader>

	<shader id="blurFX" tags="fx" macros="USE_HBLUR">
		<code type="vertex_shader">
			precision highp float;
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			varying vec2 coord;
			void main() {
				coord = a_coord; gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
			}
		</code>
		<code type="pixel_shader">
			<![CDATA[
			precision highp float;

			uniform sampler2D texture;
			varying vec2 coord;
			uniform vec4 color;
			uniform vec2 texSize;

			void main() {
				#ifdef USE_HBLUR
					vec2 delta = vec2(1.0 / 256.0, 0.0);
				#else
					vec2 delta = vec2(0.0, 1.0 / 256.0);
				#endif
				vec4 final = texture2D(texture, coord) * 0.3989422804;
				final += texture2D(texture, coord + delta) * 0.2419707245;
				final += texture2D(texture, coord - delta) * 0.2419707245;
				final += texture2D(texture, coord + delta * 2.0) * 0.0539909665;
				final += texture2D(texture, coord - delta * 2.0) * 0.0539909665;
				final += texture2D(texture, coord + delta * 3.0) * 0.0044318484;
				final += texture2D(texture, coord - delta * 3.0) * 0.0044318484;
				gl_FragColor = final * color;
			}
			]]>
		</code>
	</shader>
	<!--
	<shader id="" tags="">
		<code id="vertex_shader">

		</code>
		<code id="pixel_shader">

		</code>
	</shader>
	-->
</shaders>