<micro_shader_library>
	<micro_shader>
		<name>light_directional</name>
		<header><![CDATA[
			uniform vec3	uLDirection;
			uniform float	uLIntensity;
			]]>
		</header>
		<maincode><![CDATA[
			attenuation = 1.0;
			lightDirection = normalize(-uLDirection);
			lightIntensity = uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_point</name>
		<header><![CDATA[
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float	uLRange;
			uniform float	uLIntensity;
			//uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;
			uniform float uLNear,uLFar;

			vec3 	positionToLightSource;
			float 	distance;
			]]>
		</header>
		<maincode><![CDATA[
			vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - v_position);
			float distance = length(positionToLightSource);
			lightDirection = normalize(positionToLightSource);
			//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;
			lightIntensity = uLIntensity;
			]]>				
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_spot</name>
		<header><![CDATA[
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float	uLRange;
			uniform float	uLIntensity;
			uniform float	uLSpotAngle;
			uniform float	uLSpotExponent;
			//uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;
			uniform float uLNear,uLFar;

			vec3  	positionToLightSource;
			float 	distance;
			float 	clampedCosine;
			]]>
		</header>
		<maincode><![CDATA[
			vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - v_position);
			float distance = length(positionToLightSource);
			lightDirection = normalize(positionToLightSource);
			//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;

			float clampedCosine = max(0.0, dot(-lightDirection, normalize(uLDirection)));
			if (clampedCosine < cos(radians(uLSpotAngle))){ 								// outside of spotlight cone?
			attenuation = 0.0;
			}else{
			attenuation = attenuation * pow(clampedCosine, uLSpotExponent);   
			}
			lightIntensity = uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_phong</name>
		<header><![CDATA[
			uniform vec4 	uLDiffuse;
			uniform vec4 	uLSpecular;
			uniform vec4 	uLAmbient;
			]]>
		</header>
		<maincode><![CDATA[
			lightDiffuse = vec3(uLDiffuse);
			lightSpecular = vec3(uLSpecular);
			lightAmbient = vec3(uLAmbient);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>phong</name>
		<header><![CDATA[
			varying vec3 v_normal;  // surface normal vector in world space
			varying vec4 v_position;  // position of the vertex (and fragment) in world space
			uniform mat4 v_inv;

			vec3 	normalDirection;
			vec3  	lightDirection;
			vec3 	viewDirection;
			float 	attenuation = 1.0;
			vec3 	lightDiffuse = vec3(1.0,1.0,1.0);
			vec3 	lightSpecular = vec3(1.0,1.0,1.0);
			vec3 	lightAmbient = vec3(1.0,1.0,1.0);


			]]>
		</header>
		<maincode><![CDATA[
			normalDirection = normalize(v_normal);
			viewDirection = normalize(vec3(v_inv * vec4(0.0, 0.0, 0.0, 1.0) - v_position));
			ambientLighting = lightAmbient ;
			
			diffuseReflection = attenuation * lightDiffuse * max(0.0, dot(normalDirection, lightDirection));
			
			if (dot(normalDirection, lightDirection) < 0.0){ 	// light source on the wrong side?
				specularReflection = vec3(0.0, 0.0, 0.0); 		// no specular reflection
			}else{ 												// light source on the right side
				specularReflection = attenuation * lightSpecular  * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), 1.0);
			}
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>basic_fragment</name>
		<header><![CDATA[
			varying vec2 v_coord;
			uniform sampler2D uTexture;
			uniform vec4 uOColor;

			vec3 	ambientLighting = vec3(1.0,1.0,1.0);
			vec3 	diffuseReflection = vec3(1.0,1.0,1.0);
			vec3 	specularReflection = vec3(1.0,1.0,1.0);
			float	lightIntensity = 1.0;
			vec4 	albedoColor;
			]]>		
		</header>
		<maincode><![CDATA[
			albedoColor = texture2D( uTexture, v_coord);
			gl_FragColor = uOColor * albedoColor * vec4(ambientLighting + diffuseReflection + specularReflection, 1.0) * lightIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>basic_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;

			varying vec4 v_position;  		// position of the vertex (and fragment) in world space
			varying vec3 v_normal;  // surface normal vector in world space
			varying vec2 v_coord;		

			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			uniform mat4 umodelt; 	//inverse(transpose(model))
			]]>
		</header>
		<maincode><![CDATA[
			v_coord = a_coord;
			v_position = m * vec4(a_vertex,1.0);
			v_normal = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			
			//mat4 mvp = p*v*m;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
			
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>fulllight_fragment</name>
		<header><![CDATA[
			varying vec4 v_position;  // position of the vertex (and fragment) in world space
			varying vec3 v_normal;  // surface normal vector in world space
			varying vec2 v_coord;
			uniform mat4 v_inv;
			uniform sampler2D uTexture;

			//light//
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float	uLIntensity;
			uniform int		uLType;
			uniform float	uLRange;
			uniform float	uLSpotAngle;
			uniform float	uLSpotExponent;
			uniform vec4 	uLDiffuse;
			uniform vec4 	uLSpecular;
			uniform vec4 	uLAmbient;
			//uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;
			uniform float uLNear,uLFar;

			//object//
			uniform vec4 uOColor;

			]]>
		</header>
		<maincode><![CDATA[
			vec3 normalDirection = normalize(v_normal);
			vec3 viewDirection = normalize(vec3(v_inv * vec4(0.0, 0.0, 0.0, 1.0) - v_position));
			vec3 lightDirection;
			float attenuation;
			
			if (0 == uLType){										// directional light?
				attenuation = 1.0; 									// no attenuation
				lightDirection = normalize(-uLDirection);
			}else if(1 == uLType){ 									// point light or spotlight (or other kind of light)
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - v_position);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;
			}else if(2 == uLType){
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - v_position);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;

				float clampedCosine = max(0.0, dot(-lightDirection, normalize(uLDirection)));
				if (clampedCosine < cos(radians(uLSpotAngle))){ 	// outside of spotlight cone?
					attenuation = 0.0;
				}else{
					attenuation = attenuation * pow(clampedCosine, uLSpotExponent);   
				}

			}
			
			vec3 ambientLighting = vec3(uLAmbient) ;
			
			vec3 diffuseReflection = attenuation * vec3(uLDiffuse) * max(0.0, dot(normalDirection, lightDirection));
			
			vec3 specularReflection;
			if (dot(normalDirection, lightDirection) < 0.0){ // light source on the wrong side?
				specularReflection = vec3(0.0, 0.0, 0.0); // no specular reflection
			}else{ // light source on the right side
				specularReflection = attenuation * vec3(uLSpecular) * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), 1.0);
			}
			
			vec4 color = texture2D( uTexture, v_coord);
			gl_FragColor = uOColor * color * vec4(ambientLighting + diffuseReflection + specularReflection, 1.0) * uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>fulllight_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;

			varying vec4 v_position;  		// position of the vertex (and fragment) in world space
			varying vec3 v_normal;  // surface normal vector in world space
			varying vec2 v_coord;		

			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			uniform mat4 umodelt; 	//inverse(transpose(model))
			]]>
		</header>
		<maincode><![CDATA[
			v_coord = a_coord;
			v_position = m * vec4(a_vertex,1.0);
			v_normal = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			
			//mat4 mvp = p*v*m;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>albedo_deferred_fragment</name>
		<header><![CDATA[
			varying vec2 v_coord;
			uniform sampler2D uTexture;
			]]>		
		</header>
		<maincode><![CDATA[
				vec4 color = texture2D( uTexture, v_coord);
				gl_FragColor = color;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>depth_deferred_fragment</name>
		<header><![CDATA[
			varying vec4 v_position;
			uniform vec3 cameraPosition;
			uniform float nearPlane;
			uniform float farPlane;
			]]>
		</header>
		<maincode><![CDATA[
				float d = 10.0;
				float distance = abs(length(cameraPosition - v_position.xyz));
				float x = mod(distance,d);
				distance = distance/d;
				float y = mod(distance,d);
				float z = distance/d;
				vec4 color;
				color.x =  x/d;
				color.y =  y/d;
				color.z =  z/d;
				color.w = 1.0;

				float depth = length(cameraPosition - v_position.xyz);
				depth = (depth-nearPlane)/(farPlane-nearPlane);
				vec4 depthGray = vec4(depth);

				gl_FragColor = depthGray;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>normals_deferred_fragment</name>
		<header><![CDATA[
			varying vec4 v_position;
			varying vec3 v_normal;
			uniform vec3 cameraPosition;
			]]>
		</header>
		<maincode><![CDATA[
				//gl_FragColor = normalize(vec4(abs(v_normal.xyz),0));
				vec4 normal = 0.5 * normalize(vec4(v_normal.xyz,0) + 1.0);
				 gl_FragColor = normal;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>gbuffer_fragment</name>
		<header><![CDATA[
			#extension GL_EXT_draw_buffers : require 
			varying vec2 v_coord;
			varying vec4 v_position;
			varying vec3 v_normal;
			uniform sampler2D uTexture;
			uniform vec3 cameraPosition;
			uniform float nearPlane;
			uniform float farPlane;
			]]>
		</header>
		<maincode><![CDATA[
				float depth = length(cameraPosition - v_position.xyz);
				//float depth = length(cameraPosition - vec3(100,100,100));
				depth = (depth-nearPlane)/(farPlane-nearPlane);


				gl_FragData[0] = texture2D( uTexture, v_coord);
				gl_FragData[1] = vec4(vec3(depth),1.0);
				gl_FragData[2] = normalize(vec4(v_normal.xyz,0));
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>deferred_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			attribute vec3 a_normal;

			varying vec4 v_position;  		// position of the vertex (and fragment) in world space
			varying vec3 v_normal;  // surface normal vector in world space
			varying vec2 v_coord;		

			uniform mat4 umodelt;
			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			]]>
		</header>
		<maincode><![CDATA[
			v_coord = a_coord;
			v_position = m * vec4(a_vertex,1.0);
			v_normal = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>deferred_fragment_depth</name>
		<header>
			<![CDATA[
			varying vec2 v_coord;		
			uniform sampler2D uAlbedoText;
			uniform sampler2D uNormalText;
			uniform sampler2D uDepthText;
            uniform vec4 viewport;
            uniform mat4 inv_viewProject;
			uniform float nearPlane;
			uniform float farPlane;
			
            vec3 unproject(float pixelX,float pixelY,float distZ){
            
                vec4 v;
                
                v.x = (pixelX - viewport.x) * 2.0 / viewport.z - 1.0;
                v.y = (pixelY - viewport.y) * 2.0 / viewport.w - 1.0;
                v.z = 2.0 * distZ - 1.0;
                v.w = 1.0;
                
                mat4 inv_m = inv_viewProject;
                
                v = v*inv_m;
                if(v.w == 0.0) { return vec3(0.0); }
                vec3 pos;
                pos.x = v.x / v.w;
                pos.y = v.y / v.w;
                pos.z = v.z / v.w;
                
                return pos;
            
            }
			]]>
		</header>
		<maincode>
			<![CDATA[
			vec4 position = texture2D( uDepthText, v_coord);
				gl_FragColor = position;
			]]>	
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>SCREEN_VERTEX_SHADER</name>
		<header>
			<![CDATA[
      attribute vec3 a_vertex;
      attribute vec2 a_coord;
      varying vec2 v_coord;
      
    			]]>
		</header>
		<maincode>
			<![CDATA[
		v_coord = a_coord;
        gl_Position = vec4(a_coord * 2.0 - 1.0, 0.0, 1.0);
      			]]>	
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>deferred_fragment</name>
		<header>
			<![CDATA[
			varying vec2 v_coord;		
			uniform sampler2D uAlbedoText;
			uniform sampler2D uNormalText;
			uniform sampler2D uDepthText;
			
			uniform mat4 v_inv;
			uniform mat4 IM;
			uniform mat4 mvp_inv;
			uniform vec2 uScreenSize;
			uniform vec4 viewport;
			uniform mat4 remapMatrix;
			//light//
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float 	uLIntensity;
			uniform int		uLType;
			uniform float	uLRange;
			uniform float	uLSpotAngle;
			uniform float	uLSpotExponent;
			uniform vec4 	uLDiffuse;
			uniform vec4 	uLSpecular;
			uniform vec4 	uLAmbient;
			//uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;
			uniform float uLNear,uLFar;

			vec3 	lightDiffuse = vec3(1.0,1.0,1.0);
			vec3 	lightSpecular = vec3(1.0,1.0,1.0);
			vec3 	lightAmbient = vec3(1.0,1.0,1.0);
			vec3 	normalDirection;
			vec3  	lightDirection;
			vec3 	viewDirection;
			float 	attenuation = 1.0;

			vec3 	ambientLighting = vec3(1.0,1.0,1.0);
			vec3 	diffuseReflection = vec3(1.0,1.0,1.0);
			vec3 	specularReflection = vec3(1.0,1.0,1.0);

			]]>
		</header>
		<maincode>
			<![CDATA[
			vec2 coord = gl_FragCoord.xy / uScreenSize;
			//vec4 position = texture2D( uDepthText, coord);
			

			// http://www.gamedev.net/topic/498615-how-can-i-get-the-world-coordinates-in-a-glsl-pixel-shader-by-using-the-depth-value/
			vec2 screen = (vec2(gl_FragCoord.x, gl_FragCoord.y) - viewport.xy) * viewport.zw;
			float depth = 	texture2D( uDepthText, coord).x;
			vec4 world = IM * vec4(screen, depth, 1.0);
			world.xyz /= world.w;
			vec4 position = vec4(world.xyz,1.0);

			//vec4 posScreenCoords = vec4(coord.x,coord.y,depth,1.0);
			//vec4 position2 = posScreenCoords * mvp_inv;

			vec4 normal = texture2D( uNormalText, coord);
			vec4 albedoColor = texture2D( uAlbedoText, coord);
			
			if (0 == uLType || 3 == uLType){										// directional light?
				attenuation = 1.0;
				lightDirection = normalize(-uLDirection);
			}else if(1 == uLType){ 									// point light or spotlight (or other kind of light)
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - position);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;
			}else if(2 == uLType){
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - position);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				//attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
				if (distance >= uLFar)
					attenuation = 0.0;
				else if (distance >= uLNear)
					attenuation = 1.0 - (distance - uLNear) / (uLFar - uLNear);
				else 
					attenuation = 1.0;

				float clampedCosine = max(0.0, dot(-lightDirection, normalize(uLDirection)));
				if (clampedCosine < cos(radians(uLSpotAngle))){ 	// outside of spotlight cone?
					attenuation = 0.0;
				}else{
					attenuation = attenuation * pow(clampedCosine, uLSpotExponent);   
				}

			}

			lightDiffuse = vec3(uLDiffuse);
			lightSpecular = vec3(uLSpecular);
			lightAmbient = vec3(uLAmbient);

			
			normalDirection = normalize(normal.xyz);
			viewDirection = normalize(vec3(v_inv * vec4(0.0, 0.0, 0.0, 1.0) - position));
			
			diffuseReflection = attenuation * lightDiffuse * max(0.0, dot(normalDirection, lightDirection));
			
			if (dot(normalDirection, lightDirection) < 0.0){ 	// light source on the wrong side?
				specularReflection = vec3(0.0, 0.0, 0.0); 		// no specular reflection
			}else{ 												// light source on the right side
				specularReflection = attenuation * lightSpecular  * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), 1.0);
			}

			gl_FragColor = position; //albedoColor * vec4(lightAmbient + diffuseReflection + specularReflection, 1.0) * uLIntensity;
			]]>	
		</maincode>
	</micro_shader>
</micro_shader_library>