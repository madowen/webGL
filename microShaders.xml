<micro_shader_library>
	<micro_shader>
		<name>light_directional</name>
		<header><![CDATA[
			uniform vec3	uLDirection;
			uniform float	uLIntensity;
			]]>
		</header>
		<maincode><![CDATA[
			attenuation = 1.0;
			lightDirection = normalize(-uLDirection);
			lightIntensity = uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_point</name>
		<header><![CDATA[
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float	uLRange;
			uniform float	uLIntensity;
			uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;

			vec3 	positionToLightSource;
			float 	distance;
			]]>
		</header>
		<maincode><![CDATA[
			vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - vPosition);
			float distance = length(positionToLightSource);
			lightDirection = normalize(positionToLightSource);
			attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
			lightIntensity = uLIntensity;
			]]>				
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_spot</name>
		<header><![CDATA[
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform float	uLRange;
			uniform float	uLIntensity;
			uniform float	uLSpotAngle;
			uniform float	uLSpotExponent;
			uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;

			vec3  	positionToLightSource;
			float 	distance;
			float 	clampedCosine;
			]]>
		</header>
		<maincode><![CDATA[
			vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - vPosition);
			float distance = length(positionToLightSource);
			lightDirection = normalize(positionToLightSource);
			attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);

			float clampedCosine = max(0.0, dot(-lightDirection, normalize(uLDirection)));
			if (clampedCosine < cos(radians(uLSpotAngle))){ 								// outside of spotlight cone?
			attenuation = 0.0;
			}else{
			attenuation = attenuation * pow(clampedCosine, uLSpotExponent);   
			}
			lightIntensity = uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>light_phong</name>
		<header><![CDATA[
			uniform vec4 	uLDiffuse;
			uniform vec4 	uLSpecular;
			uniform vec4 	uLAmbient;
			]]>
		</header>
		<maincode><![CDATA[
			lightDiffuse = vec3(uLDiffuse);
			lightSpecular = vec3(uLSpecular);
			lightAmbient = vec3(uLAmbient);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>phong</name>
		<header><![CDATA[
			varying vec3 vNormalDirection;  // surface normal vector in world space
			varying vec4 vPosition;  // position of the vertex (and fragment) in world space
			uniform mat4 v_inv;

			vec3 	normalDirection;
			vec3  	lightDirection;
			vec3 	viewDirection;
			float 	attenuation = 1.0;
			vec3 	lightDiffuse = vec3(1.0,1.0,1.0);
			vec3 	lightSpecular = vec3(1.0,1.0,1.0);
			vec3 	lightAmbient = vec3(1.0,1.0,1.0);

			struct material
			{
			vec4 ambient;
			vec4 diffuse;
			vec4 specular;
			float shininess;
			};
			material frontMaterial = material(
			vec4(0.4, 0.4, 0.4, 1.0),
			vec4(0.8, 0.8, 0.8, 1.0),
			vec4(1.0, 1.0, 1.0, 1.0),
			1.0
			);
			]]>
		</header>
		<maincode><![CDATA[
			normalDirection = normalize(vNormalDirection);
			viewDirection = normalize(vec3(v_inv * vec4(0.0, 0.0, 0.0, 1.0) - vPosition));
			ambientLighting = lightAmbient * vec3(frontMaterial.ambient);
			
			diffuseReflection = attenuation * lightDiffuse * vec3(frontMaterial.diffuse) * max(0.0, dot(normalDirection, lightDirection));
			
			if (dot(normalDirection, lightDirection) < 0.0){ 	// light source on the wrong side?
			specularReflection = vec3(0.0, 0.0, 0.0); 		// no specular reflection
			}else{ 												// light source on the right side
			specularReflection = attenuation * lightSpecular * vec3(frontMaterial.specular) * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), frontMaterial.shininess);
			}
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>basic_fragment</name>
		<header><![CDATA[
			varying vec2 vTextureCoord;
			uniform sampler2D uTexture;
			uniform vec4 uOColor;

			vec3 	ambientLighting = vec3(1.0,1.0,1.0);
			vec3 	diffuseReflection = vec3(1.0,1.0,1.0);
			vec3 	specularReflection = vec3(1.0,1.0,1.0);
			float	lightIntensity = 1.0;
			vec4 	color;
			]]>		
		</header>
		<maincode><![CDATA[
			color = texture2D( uTexture, vTextureCoord);
			gl_FragColor = uOColor * color * vec4(ambientLighting + diffuseReflection + specularReflection, 1.0) * lightIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>basic_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;

			varying vec4 vPosition;  		// position of the vertex (and fragment) in world space
			varying vec3 vNormalDirection;  // surface normal vector in world space
			varying vec2 vTextureCoord;		

			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			uniform mat4 umodelt; 	//inverse(transpose(model))
			]]>
		</header>
		<maincode><![CDATA[
			vTextureCoord = a_coord;
			vPosition = m * vec4(a_vertex,1.0);
			vNormalDirection = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			
			//mat4 mvp = p*v*m;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
			
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>fulllight_fragment</name>
		<header><![CDATA[
			varying vec4 vPosition;  // position of the vertex (and fragment) in world space
			varying vec3 vNormalDirection;  // surface normal vector in world space
			varying vec2 vTextureCoord;
			uniform mat4 m, v, p;
			uniform mat4 v_inv;
			uniform sampler2D uTexture;

			//light//
			uniform vec3	uLPosition;
			uniform vec3	uLDirection;
			uniform int		uLType;
			uniform float	uLRange;
			uniform float	uLSpotAngle;
			uniform float	uLSpotExponent;
			uniform vec4 	uLDiffuse;
			uniform vec4 	uLSpecular;
			uniform vec4 	uLAmbient;
			uniform float 	uLConstantAttenuation, uLLinearAttenuation, uLQuadraticAttenuation;

			//object//
			uniform vec4 uOColor;

			
			struct material
			{
			vec4 ambient;
			vec4 diffuse;
			vec4 specular;
			float shininess;
			};
			material frontMaterial = material(
			vec4(0.4, 0.4, 0.4, 1.0),
			vec4(1.0, 0.8, 0.8, 1.0),
			vec4(1.0, 1.0, 1.0, 1.0),
			1.0
			);
			]]>
		</header>
		<maincode><![CDATA[
			vec3 normalDirection = normalize(vNormalDirection);
			vec3 viewDirection = normalize(vec3(v_inv * vec4(0.0, 0.0, 0.0, 1.0) - vPosition));
			vec3 lightDirection;
			float attenuation;
			
			if (0 == uLType){										// directional light?
				attenuation = 1.0; 									// no attenuation
				lightDirection = normalize(-uLDirection);
			}else if(1 == uLType){ 									// point light or spotlight (or other kind of light)
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - vPosition);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);
			}else if(2 == uLType){
				vec3 positionToLightSource = vec3(vec4(uLPosition,1.0) - vPosition);
				float distance = length(positionToLightSource);
				lightDirection = normalize(positionToLightSource);
				attenuation = uLRange * 1.0 / (uLConstantAttenuation + uLLinearAttenuation * distance + uLQuadraticAttenuation * distance * distance);

				float clampedCosine = max(0.0, dot(-lightDirection, normalize(uLDirection)));
				if (clampedCosine < cos(radians(uLSpotAngle))){ 	// outside of spotlight cone?
					attenuation = 0.0;
				}else{
					attenuation = attenuation * pow(clampedCosine, uLSpotExponent);   
				}

			}
			
			vec3 ambientLighting = vec3(uLAmbient) * vec3(frontMaterial.ambient);
			
			vec3 diffuseReflection = attenuation * vec3(uLDiffuse) * vec3(frontMaterial.diffuse) * max(0.0, dot(normalDirection, lightDirection));
			
			vec3 specularReflection;
			if (dot(normalDirection, lightDirection) < 0.0){ // light source on the wrong side?
				specularReflection = vec3(0.0, 0.0, 0.0); // no specular reflection
			}else{ // light source on the right side
				specularReflection = attenuation * vec3(uLSpecular) * vec3(frontMaterial.specular) * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), frontMaterial.shininess);
			}
			
			vec4 color = texture2D( uTexture, vTextureCoord);
			gl_FragColor = uOColor * color * vec4(ambientLighting + diffuseReflection + specularReflection, 1.0) * uLIntensity;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>fulllight_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec3 a_normal;
			attribute vec2 a_coord;

			varying vec4 vPosition;  		// position of the vertex (and fragment) in world space
			varying vec3 vNormalDirection;  // surface normal vector in world space
			varying vec2 vTextureCoord;		

			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			uniform mat4 umodelt; 	//inverse(transpose(model))
			]]>
		</header>
		<maincode><![CDATA[
			vTextureCoord = a_coord;
			vPosition = m * vec4(a_vertex,1.0);
			vNormalDirection = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			
			//mat4 mvp = p*v*m;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>albedo_deferred_fragment</name>
		<header><![CDATA[
			varying vec2 vTextureCoord;
			uniform sampler2D uTexture;
			]]>		
		</header>
		<maincode><![CDATA[
				vec4 color = texture2D( uTexture, vTextureCoord);
				gl_FragColor = color;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>depth_deferred_fragment</name>
		<header><![CDATA[
			varying vec4 vPosition;
			uniform vec3 cameraPosition;
			uniform float nearPlane;
			uniform float farPlane;
			]]>
		</header>
		<maincode><![CDATA[
				float d = 10.0;
				float distance = abs(length(cameraPosition - vPosition.xyz));
				float x = mod(distance,d);
				distance = distance/d;
				float y = mod(distance,d);
				float z = distance/d;
				vec4 color;
				color.x =  x/d;
				color.y =  y/d;
				color.z =  z/d;
				color.w = 1.0;

				float depth = length(cameraPosition - vPosition.xyz);
				depth = (depth-nearPlane)/(farPlane-nearPlane);
				vec4 depthGray = vec4(depth);

				gl_FragColor = depthGray;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>normals_deferred_fragment</name>
		<header><![CDATA[
			varying vec4 vPosition;
			varying vec3 vNormalDirection;
			uniform vec3 cameraPosition;
			]]>
		</header>
		<maincode><![CDATA[
				//gl_FragColor = normalize(vec4(abs(vNormalDirection.xyz),0));
				vec4 normal = 0.5 * normalize(vec4(vNormalDirection.xyz,0) + 1.0);
				 gl_FragColor = normal;
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>gbuffer_fragment</name>
		<header><![CDATA[
			#extension GL_EXT_draw_buffers : require 
			varying vec2 vTextureCoord;
			varying vec4 vPosition;
			varying vec3 vNormalDirection;
			uniform sampler2D uTexture;
			uniform vec3 cameraPosition;
			uniform float nearPlane;
			uniform float farPlane;
			]]>
		</header>
		<maincode><![CDATA[
				float depth = length(cameraPosition - vPosition.xyz);
				depth = (depth-nearPlane)/(farPlane-nearPlane);


				gl_FragData[0] = texture2D( uTexture, vTextureCoord);
				gl_FragData[1] = vec4(depth);
				gl_FragData[2] = abs(normalize(vec4(vNormalDirection.xyz,0)));
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>deferred_vertex</name>
		<header><![CDATA[
			attribute vec3 a_vertex;
			attribute vec2 a_coord;
			attribute vec3 a_normal;

			varying vec4 vPosition;  		// position of the vertex (and fragment) in world space
			varying vec3 vNormalDirection;  // surface normal vector in world space
			varying vec2 vTextureCoord;		

			uniform mat4 umodelt;
			uniform mat4 m, v, p;			//model, view, projection
			uniform mat4 mvp;
			]]>
		</header>
		<maincode><![CDATA[
			vTextureCoord = a_coord;
			vPosition = m * vec4(a_vertex,1.0);
			vNormalDirection = normalize(umodelt * vec4(a_normal,1.0)).xyz;
			gl_Position = mvp * vec4(a_vertex,1.0);
			]]>
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>deferred_fragment</name>
		<header>
			<![CDATA[
			varying vec2 v_coord;		
			uniform sampler2D uAlbedoText;
			uniform sampler2D uNormalText;
			uniform sampler2D uDepthText;
            uniform vec4 viewport;
            uniform mat4 viewProject;
            uniform mat4 inv_viewProject;

            vec3 depthToWorld(float pixelX,float pixelY,float distZ){
            
                vec4 v;
                
                v.x = (pixelX - viewport.x) * 2.0 / viewport.z - 1.0;
                v.y = (pixelY - viewport.y) * 2.0 / viewport.w - 1.0;
                v.z = 2.0 * distZ - 1.0;
                v.w = 1.0;
                
                mat4 m = viewProject;
                mat4 inv_m = inv_viewProject;
                //if(!m) { return null; }
                
                v = v*m;
                if(v.w == 0.0) { return vec3(0.0); }
                vec3 pos;
                pos.x = v.x / v.w;
                pos.y = v.y / v.w;
                pos.z = v.z / v.w;
                
                return pos;
            
            }
			]]>
		</header>
		<maincode>
			<![CDATA[
			vec4 color = texture2D( uDepthText, v_coord);
            vec3 pos = depthToWorld(v_coord.x, v_coord.y, color.x);
			gl_FragColor = vec4(pos,1.0);
			]]>	
		</maincode>
	</micro_shader>
	<micro_shader>
		<name>SCREEN_VERTEX_SHADER</name>
		<header>
			<![CDATA[
      attribute vec3 a_vertex;
      attribute vec2 a_coord;
      varying vec2 v_coord;
      
    			]]>
		</header>
		<maincode>
			<![CDATA[
		v_coord = a_coord;
        gl_Position = vec4(a_coord * 2.0 - 1.0, 0.0, 1.0);
      			]]>	
		</maincode>
	</micro_shader>
</micro_shader_library>