<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script> <!-- mat4 library -->
		<script type="text/javascript" src="webgl-utils.js"></script> <!--Google-provided to unite all browser under one function declaration name-->
		<style type="text/css">
			#loadingtext {
			    position:absolute;
			    top:250px;
			    left:150px;
			    font-size:2em;
			    color: white;
			}
		</style>
		<script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			uniform sampler2D uSampler;
			
			void main(void) {
				vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
			}
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			
			uniform vec3 uAmbientColor;
			
			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			uniform bool uUseLighting;
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			void main(void) {
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
				
				if (!uUseLighting) {
					vLightWeighting = vec3(1.0, 1.0, 1.0);
				} else {
					vec3 transformedNormal = uNMatrix * aVertexNormal;
					float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
					vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
				}
			}
		</script>
				
		<script type="text/javascript">

		function GameObject(position){
			this.pos = position;
			this.pitch = 0;
			this.yaw = 0;
			this.roll = 0;
			this.scale = [1.0,1.0,1.0];
			this.rCube = 0;
			this.components = [];
		
			GameObject.prototype.update = function(elapsed){
				this.rCube += (70 * elapsed) / 1000.0;
				for (var i in this.components){
					this.components[i].update(elapsed);
				}
			}
	
			GameObject.prototype.addComponent = function(name, obj){
				obj.parentNode = this;
				this.components[name] = obj;			
			}

		}

		var currentlyPressedKeys = {};

		function KeyController(){
				
			KeyController.prototype.update = function(elapsed){
				if (currentlyPressedKeys[65]) {
					// A
					this.parentNode.pos[0] -= 10*elapsed/1000;
				}
				if (currentlyPressedKeys[68]) {
					// D
					this.parentNode.pos[0] += 10*elapsed/1000;
				}
				if (currentlyPressedKeys[87]) {
					// W
					this.parentNode.pos[2] -= 10*elapsed/1000;
				}
				if (currentlyPressedKeys[83]) {
					// S
					this.parentNode.pos[2] += 10*elapsed/1000;
				}
			}
			
		}
		
		function Renderer(texture, fragmentShader, vertexShader){

			this.pathTexture = texture;
			this.shaderProgram = null;
		
			//public methods
			Renderer.prototype.update = function(elapsed){
				//console.log("render update");
			}
					
			Renderer.prototype.initBuffer = function(){
				this.vertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
				vertices = [
					// Front face
					-1.0, -1.0,  1.0,
					 1.0, -1.0,  1.0,
					 1.0,  1.0,  1.0,
					-1.0,  1.0,  1.0,
					
					// Back face
					-1.0, -1.0, -1.0,
					-1.0,  1.0, -1.0,
					 1.0,  1.0, -1.0,
					 1.0, -1.0, -1.0,
					
					// Top face
					-1.0,  1.0, -1.0,
					-1.0,  1.0,  1.0,
					 1.0,  1.0,  1.0,
					 1.0,  1.0, -1.0,
					
					// Bottom face
					-1.0, -1.0, -1.0,
					 1.0, -1.0, -1.0,
					 1.0, -1.0,  1.0,
					-1.0, -1.0,  1.0,
					
					// Right face
					1.0, -1.0, -1.0,
					1.0,  1.0, -1.0,
					1.0,  1.0,  1.0,
					1.0, -1.0,  1.0,
					
					// Left face
					-1.0, -1.0, -1.0,
					-1.0, -1.0,  1.0,
					-1.0,  1.0,  1.0,
					-1.0,  1.0, -1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				this.vertexPositionBuffer.itemSize = 3;
				this.vertexPositionBuffer.numItems = 24;
				
				
				this.vertexNormalBuffer = gl.createBuffer();
			    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
			    var vertexNormals = [
			      // Front face
			       0.0,  0.0,  1.0,
			       0.0,  0.0,  1.0,
			       0.0,  0.0,  1.0,
			       0.0,  0.0,  1.0,
			
			      // Back face
			       0.0,  0.0, -1.0,
			       0.0,  0.0, -1.0,
			       0.0,  0.0, -1.0,
			       0.0,  0.0, -1.0,
			
			      // Top face
			       0.0,  1.0,  0.0,
			       0.0,  1.0,  0.0,
			       0.0,  1.0,  0.0,
			       0.0,  1.0,  0.0,
			
			      // Bottom face
			       0.0, -1.0,  0.0,
			       0.0, -1.0,  0.0,
			       0.0, -1.0,  0.0,
			       0.0, -1.0,  0.0,
			
			      // Right face
			       1.0,  0.0,  0.0,
			       1.0,  0.0,  0.0,
			       1.0,  0.0,  0.0,
			       1.0,  0.0,  0.0,
			
			      // Left face
			      -1.0,  0.0,  0.0,
			      -1.0,  0.0,  0.0,
			      -1.0,  0.0,  0.0,
			      -1.0,  0.0,  0.0,
			    ];
			    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
			    this.vertexNormalBuffer.itemSize = 3;
			    this.vertexNormalBuffer.numItems = 24;
				
				
				this.vertexTextureCoordBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
				var textureCoords = [
					// Front face
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					
					// Back face
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					0.0, 0.0,
					
					// Top face
					0.0, 1.0,
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					
					// Bottom face
					1.0, 1.0,
					0.0, 1.0,
					0.0, 0.0,
					1.0, 0.0,
					
					// Right face
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
					0.0, 0.0,
					
					// Left face
					0.0, 0.0,
					1.0, 0.0,
					1.0, 1.0,
					0.0, 1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
				this.vertexTextureCoordBuffer.itemSize = 2;
				this.vertexTextureCoordBuffer.numItems = 24;
					
				this.vertexIndexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
				var vertexIndices = [
					0, 1, 2,      0, 2, 3,    // Front face
					4, 5, 6,      4, 6, 7,    // Back face
					8, 9, 10,     8, 10, 11,  // Top face
					12, 13, 14,   12, 14, 15, // Bottom face
					16, 17, 18,   16, 18, 19, // Right face
					20, 21, 22,   20, 22, 23  // Left face
				];
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
				this.vertexIndexBuffer.itemSize = 1;
				this.vertexIndexBuffer.numItems = 36;
				
			}
			
			Renderer.prototype.render = function(){

				mvPushMatrix();
				//console.log(this.parentNode.pos[0],this.parentNode.pos[1],this.parentNode.pos[2]);
				mat4.translate(mvMatrix, this.parentNode.pos);
				
				mat4.rotate(mvMatrix, degToRad(this.parentNode.rCube), [1, 1, 1]);
	
				// vertices arrays (position,normal,texture coord)
			    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
				gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer);
				gl.vertexAttribPointer(this.shaderProgram.vertexNormalAttribute, this.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
				gl.vertexAttribPointer(this.shaderProgram.textureCoordAttribute, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.uniform1i(this.shaderProgram.samplerUniform, 0);
	
				// lighting
				var lighting = document.getElementById("lighting").checked; //html checkbox
				gl.uniform1i(this.shaderProgram.useLightingUniform, lighting);
				
				if (lighting) {
					gl.uniform3f(
						this.shaderProgram.ambientColorUniform,
						parseFloat(document.getElementById("ambientR").value),
						parseFloat(document.getElementById("ambientG").value),
						parseFloat(document.getElementById("ambientB").value)
					);
					var lightingDirection = [
						parseFloat(document.getElementById("lightDirectionX").value),
						parseFloat(document.getElementById("lightDirectionY").value),
						parseFloat(document.getElementById("lightDirectionZ").value)
					];
					var adjustedLD = vec3.create();
					vec3.normalize(lightingDirection, adjustedLD);	//normalizamos ya que la direccion la introduce el usuario
					vec3.scale(adjustedLD, -1);						//invertimos el vector, ya que el usuario indica la direccion, pero  queremos saber de donde viene la luz
					gl.uniform3fv(this.shaderProgram.lightingDirectionUniform, adjustedLD);
					gl.uniform3f(
						this.shaderProgram.directionalColorUniform,
						parseFloat(document.getElementById("directionalR").value),
						parseFloat(document.getElementById("directionalG").value),
						parseFloat(document.getElementById("directionalB").value)
					);
				}
	
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);			
				
				//setMatrixUniforms(); //assigns matrices to the shader
				gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, mvMatrix);
				
				var normalMatrix = mat3.create();
				mat4.toInverseMat3(mvMatrix, normalMatrix);
				mat3.transpose(normalMatrix);
				gl.uniformMatrix3fv(this.shaderProgram.nMatrixUniform, false, normalMatrix);
				////////////
				
				gl.drawElements(gl.TRIANGLES, this.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);			
				
				mvPopMatrix();
			}
						
			Renderer.prototype.initTexture = function(){
				var text = gl.createTexture();
				text.image = new Image();
				//text.image.crossOrigin = "anonymous";
				text.image.onload = function() {
					handleLoadedTexture(text,text.image)
				}
				text.image.src = this.pathTexture;
				this.texture = text;
			}
				
			Renderer.prototype.initShader = function() {
				var fragmentShader = getShader(gl, "shader-fs"); 	// gets the fragment shader script
				var vertexShader = getShader(gl, "shader-vs");		// gets the vertex shader script
				
				this.shaderProgram = gl.createProgram();					// creates a program - program = A program is a bit of code that lives on the WebGL side of the system; you can look at it as a way of specifying something that can run on the graphics card.
				gl.attachShader(this.shaderProgram, vertexShader);		// attaches shaders to the program
				gl.attachShader(this.shaderProgram, fragmentShader);		// each program can hold only one vertex and one fragment shader
				gl.linkProgram(this.shaderProgram);						// link to context
				
				if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}
				
				gl.useProgram(this.shaderProgram);
			
				this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");	// save in the program the vertexPositionAttribute
			    gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);								// we tell webGL that we will use an array for the vertices
			    
				this.shaderProgram.textureCoordAttribute = gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
				gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
				
				this.shaderProgram.vertexNormalAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexNormal");
				gl.enableVertexAttribArray(this.shaderProgram.vertexNormalAttribute);
		
		
				this.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uPMatrix");		//store uniform vars on the program
				this.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
				this.shaderProgram.nMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uNMatrix");
				this.shaderProgram.samplerUniform = gl.getUniformLocation(this.shaderProgram, "uSampler");
	//				this.shaderProgram.alphaUniform = gl.getUniformLocation(this.shaderProgram, "uAlpha");
				this.shaderProgram.useLightingUniform = gl.getUniformLocation(this.shaderProgram, "uUseLighting");
				this.shaderProgram.ambientColorUniform = gl.getUniformLocation(this.shaderProgram, "uAmbientColor");
				this.shaderProgram.lightingDirectionUniform = gl.getUniformLocation(this.shaderProgram, "uLightingDirection");
				this.shaderProgram.directionalColorUniform = gl.getUniformLocation(this.shaderProgram, "uDirectionalColor");
			}

			//private methods
			var handleLoadedTexture = function(texture,image){ // PRIVATE FUNCTION
		
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);	//flip the coordinates because of gif format
		
				gl.bindTexture(gl.TEXTURE_2D, texture);			// set "current" texture = texture
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);	//upload the texture to the graphics card
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);		//filtering the texture
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);		//
				gl.generateMipmap(gl.TEXTURE_2D);
		
				gl.bindTexture(gl.TEXTURE_2D, null);			// set "current" texture = null
					
			}		
			
			var getShader = function(gl, id) {
				var shaderScript = document.getElementById(id);
				if (!shaderScript) {
					return null;
				}
				
				var str = "";
				var k = shaderScript.firstChild;
				while (k) {
					if (k.nodeType == 3) {
						str += k.textContent;
					}
					k = k.nextSibling;
				}
				
				var shader;
				if (shaderScript.type == "x-shader/x-fragment") {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == "x-shader/x-vertex") {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}
				
				gl.shaderSource(shader, str);
				gl.compileShader(shader);
				
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert(gl.getShaderInfoLog(shader));
					return null;
				}
				return shader;
			}
			
		}
		
		function Camera(f,r,np,fp){
			this.fov = f; 										//field of view
			this.ratio = r; 									//ratio width-to-height
			this.near_plane = np; 								//we don’t want to see things that are closer than 0.1 units to our viewpoint
			this.far_plane = fp;								//we don’t want to see things that are further away than 100.0 units to our viewpoint

			Camera.prototype.update = function(elapsed){
				//console.log("render update");
			}
		}


		var mvMatrix = mat4.create();
		var mvMatrixStack = [];
		var pMatrix = mat4.create();


		var objects = [];
		var cameras = [];
		var activeCamera = 0;
		
		var gl; // webGL context
		var lastTime = 0;

		function handleKeyDown(event) {
			//console.log(event.keyCode);
			if (event.keyCode == 67)
				activeCamera = (activeCamera + 1) % cameras.length;
			currentlyPressedKeys[event.keyCode] = true;
		}
		
		function handleKeyUp(event) {
			currentlyPressedKeys[event.keyCode] = false;
		}

		function mvPushMatrix() {
			var copy = mat4.create();
			mat4.set(mvMatrix, copy);
			mvMatrixStack.push(copy);
		}
		
		function mvPopMatrix() {
			if (mvMatrixStack.length == 0) {
				throw "Invalid popMatrix!";
			}
			mvMatrix = mvMatrixStack.pop();
		}
		
		function degToRad(degrees) {
			return degrees * Math.PI / 180;
		}

		function loadFile(name) {
	        var request = new XMLHttpRequest();
	        request.open("GET", name);
	        request.onreadystatechange = function () {
	            if (request.readyState == 4) {
	                handleLoadedWorld(request.responseText);
	            }
	        }
	        request.send();
	    }

		function initGL(canvas) {
			try {
				gl = canvas.getContext("webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			} catch(e) {
			}
			if (!gl) {
				alert("Could not initialise WebGL, sorry :-( ");
			}
		}

		function webGLStart() {
			var canvas = document.getElementById("lesson01-canvas");
			initGL(canvas);
			
			//for (var i = 0; i < 1; i++){
				objects[0] = new GameObject([-5+0*3,0.0,-30]);
				var ren = new Renderer("crate.gif");
				objects[0].addComponent("renderer", ren);
			//}
			objects[1] = new GameObject([-5+0*3,0.0,-20]);
			var cam = new Camera(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
			var kc = new KeyController();
			objects[1].addComponent("keyController", kc);
			objects[1].addComponent("camera", cam);
			cameras.push(cam);
	
			objects[2] = new GameObject([0,0,0]);
			var cam = new Camera(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
			objects[2].addComponent("camera", cam);
			cameras.push(cam);
			
			
			initShaders();
			initBuffers();
			initTextures();
			
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);
			
			document.onkeydown = handleKeyDown; //callback when keydown to handlekeydown()
			document.onkeyup = handleKeyUp;		//callback when keyup to handlekeyup()
			
			tick();
		}
		
		function tick(){
			requestAnimFrame(tick);
			drawScene();
			update();
		}
		
		function initTextures(){
			for (var i = 0; i < objects.length; i++){
				if (objects[i].components.renderer != null)
					objects[i].components.renderer.initTexture()
			}
		}
		
		function initBuffers(){
			for (var i = 0; i < objects.length; i++){
				if (objects[i].components.renderer != null)
					objects[i].components.renderer.initBuffer();
			}
		}
		
		function initShaders(){
			for (var i = 0; i < objects.length; i++){
				if (objects[i].components.renderer != null)
					objects[i].components.renderer.initShader();
			}
		}
		
		function drawScene(){
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); 	//tell webGL about the size of the canvas
			
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 		//clear the canvas in preparation for drawing
						
			mat4.perspective(cameras[activeCamera].fov, 				//setting up the perspective with wich we want to view the scene
							 cameras[activeCamera].ratio,
							 cameras[activeCamera].near_plane,
							 cameras[activeCamera].far_plane,
							 pMatrix);
			
			mat4.identity(mvMatrix); //model view matrix = identity matrix // identity matrix is the matrix that represents a transformation that does nothing at all
			
			mat4.rotate(mvMatrix, degToRad(-cameras[activeCamera].parentNode.pitch), [1, 0, 0]);
			mat4.rotate(mvMatrix, degToRad(-cameras[activeCamera].parentNode.yaw), [0, 1, 0]);
			mat4.rotate(mvMatrix, degToRad(-cameras[activeCamera].parentNode.roll), [0, 0, 1]);
			mat4.translate(mvMatrix, [-cameras[activeCamera].parentNode.pos[0], -cameras[activeCamera].parentNode.pos[1], -cameras[activeCamera].parentNode.pos[2]]);
			
			for (var i = 0; i < objects.length; i++){
				if (objects[i].components.renderer != null)
					objects[i].components.renderer.render();
			}
		}
		
		function update(){
			var timeNow = new Date().getTime();
			if (lastTime != 0) {
				var elapsed = timeNow - lastTime;
				
				for (var i = 0; i < objects.length; i++){
						objects[i].update(elapsed);
				}
			}
			lastTime = timeNow;
		}
		</script>
	</head>
	<body onload="webGLStart();">
		
		<canvas id="lesson01-canvas" style="border: none;" width="500" height="500"></canvas>
		<!-- <div id="loadingtext">Cargando el mundo...</div>; -->
		<br/>
	    WASD to move the camera mobile
	    <br/>
	    C to swap cameras
	    <br/>
		<input type="checkbox" id="lighting" checked /> Use lighting<br/>
	
			    <h2>Directional light:</h2>
	
	    <table style="border: 0; padding: 10px;">
	        <tr>
	            <td><b>Direction:</b>
	            <td>X: <input type="text" id="lightDirectionX" value="-0.25" />
	            <td>Y: <input type="text" id="lightDirectionY" value="-0.25" />
	            <td>Z: <input type="text" id="lightDirectionZ" value="-1.0" />
	        </tr>
	        <tr>
	            <td><b>Colour:</b>
	            <td>R: <input type="text" id="directionalR" value="0.8" />
	            <td>G: <input type="text" id="directionalG" value="0.8" />
	            <td>B: <input type="text" id="directionalB" value="0.8" />
	        </tr>
	    </table>
	
	    <h2>Ambient light:</h2>
	    <table style="border: 0; padding: 10px;">
	        <tr>
	            <td><b>Colour:</b>
	            <td>R: <input type="text" id="ambientR" value="0.2" />
	            <td>G: <input type="text" id="ambientG" value="0.2" />
	            <td>B: <input type="text" id="ambientB" value="0.2" />
	        </tr>
	    </table>

		
	</body>
</html>